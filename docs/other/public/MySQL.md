# MySQL

## 1.`MySQL常见问题`

### 1.1 索引相关
1. **什么是索引?**

索引是一种数据结构,可以帮助我们快速的进行数据的查找.

2. **索引是个什么样的数据结构呢?**

索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有Hash索引,B+树索引等,而我们经常使用的InnoDB存储引擎的默认索引实现为:B+树索引.

3. **Hash索引和B+树所有有什么区别或者说优劣呢?**

首先要知道Hash索引和B+树索引的底层实现原理:

hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.

那么可以看出他们有以下的不同:

hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.
因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.

hash索引不支持使用索引进行排序,原理同上.
hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.AAAA和AAAAB的索引没有相关性.
hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.
hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.
因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.

4. **上面提到了B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据,什么是聚簇索引?**

在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据,这就是聚簇索引和非聚簇索引. 在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引.

当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.

5. **非聚簇索引一定会回表查询吗?**

不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.

举个简单的例子,假设我们在员工表的年龄上建立了索引,那么当进行select age from employee where age < 20的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.

6. **在建立索引的时候,都有哪些需要考虑的因素呢?**

建立索引的时候一般要考虑到字段的使用频率,经常作为条件进行查询的字段比较适合.如果需要建立联合索引的话,还需要考虑联合索引中的顺序.此外也要考虑其他方面,比如防止过多的所有对表造成太大的压力.这些都和实际的表结构以及查询方式有关.

7. **联合索引是什么?为什么需要注意联合索引中的顺序?**

MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.

具体原因为:

MySQL使用索引时需要索引有序,假设现在建立了"name,age,school"的联合索引,那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序.

当进行查询时,此时索引仅仅按照name严格有序,因此必须首先使用name字段进行等值查询,之后对于匹配到的列而言,其按照age字段严格有序,此时可以使用age字段用做索引查找,,,以此类推.因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.

8. **创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?**

MySQL提供了explain命令来查看语句的执行计划,MySQL在执行某个语句之前,会将该语句过一遍查询优化器,之后会拿到对语句的分析,也就是执行计划,其中包含了许多信息.
可以通过其中和索引有关的信息来分析是否命中了索引,例如possilbe_key,key,key_len等字段,分别说明了此语句可能会使用的索引,实际使用的索引以及使用的索引长度.

9. **那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?**

使用不等于查询,
列参与了数学运算或者函数
在字符串like时左边是通配符.类似于'%aaa'.
当mysql分析全表扫描比使用索引快的时候不使用索引.
当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.
以上情况,MySQL无法使用索引.

### 1.2 事务相关

1. **什么是事务?**

理解什么是事务最经典的就是转账的栗子,相信大家也都了解,这里就不再说一边了.

事务是一系列的操作,他们要符合ACID特性.最常见的理解就是:事务中的操作要么全部成功,要么全部失败.但是只是这样还不够的.

2. **ACID是什么?可以详细说一下吗?**

A=Atomicity

原子性,就是上面说的,要么全部成功,要么全部失败.不可能只执行一部分操作.

C=Consistency

系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态.

I=Isolation

隔离性: 通常来说:一个事务在完全提交之前,对其他事务是不可见的.注意前面的通常来说加了红色,意味着有例外情况.

D=Durability

持久性,一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果.

3. **同时有多个事务在进行会怎么样呢?**

多事务的并发进行一般会造成以下几个问题:

脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.
不可重复读: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.
幻读: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成"幻觉".

4. **怎么解决这些问题呢? MySQL的事务隔离级别了解吗?**

MySQL的四种隔离级别如下:

未提交读(READ UNCOMMITTED)
这就是上面所说的例外情况了,这个隔离级别下,其他事务可以看到本事务没有提交的部分修改.因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚).

这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.

已提交读(READ COMMITTED)
其他事务只能读取到本事务已经提交的部分.这个隔离级别有 不可重复读的问题,在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改.

REPEATABLE READ(可重复读)
可重复读隔离级别解决了上面不可重复读的问题(看名字也知道),但是仍然有一个新问题,就是 幻读,当你读取id> 10 的数据行时,对涉及到的所有行加上了读锁,此时例外一个事务新插入了一条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥,那么进行本事务进行下一次的查询时会发现有一条id=11的数据,而上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题.

SERIALIZABLE(可串行化)
这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用.

5. **Innodb使用的是哪种隔离级别呢?**

InnoDB默认使用的是可重复读隔离级别.

6. **对MySQL的锁了解吗?**

当数据库有并发事务的时候,可能会产生数据的不一致,这时候需要一些机制来保证访问的次序,锁机制就是这样的一个机制.

就像酒店的房间,如果大家随意进出,就会出现多人抢夺同一个房间的情况,而在房间上装上锁,申请到钥匙的人才可以入住并且将房间锁起来,其他人只有等他使用完毕才可以再次使用.

7. **MySQL都有哪些锁呢? 像上面那样子进行锁定岂不是有点阻碍并发效率了?**

从锁的类别上来讲,有共享锁和排他锁.

共享锁: 又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个.

排他锁: 又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.

用上面的例子来说就是用户的行为有两种,一种是来看房,多个用户一起看房是可以接受的. 一种是真正的入住一晚,在这期间,无论是想入住的还是想看房的都不可以.

锁的粒度取决于具体的存储引擎,InnoDB实现了行级锁,页级锁,表级锁.

他们的加锁开销从大大小,并发能力也是从大到小.

### 1.3 表结构设计

1. **为什么要尽量设定一个主键?**

主键是数据库确保数据行在整张表唯一性的保障,即使业务上本张表没有主键,也建议添加一个自增长的ID列作为主键.设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全.

2. **主键使用自增ID还是UUID?**

推荐使用自增ID,不要使用UUID.

因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.

总之,在数据量大一些的情况下,用自增主键性能会好一些.

关于主键是聚簇索引,如果没有主键,InnoDB会选择一个唯一键来作为聚簇索引,如果没有唯一键,会生成一个隐式的主键.

If you define a PRIMARY KEY on your table, InnoDB uses it as the clustered index.

If you do not define a PRIMARY KEY for your table, MySQL picks the first UNIQUE index that has only NOT NULL columns as the primary key and InnoDB uses it as the clustered index.

3. **字段为什么要求定义为not null?**

MySQL官网这样介绍:

NULL columns require additional space in the rowto record whether their values are NULL. For MyISAM tables, each NULL columntakes one bit extra, rounded up to the nearest byte.

null值会占用更多的字节,且会在程序中造成很多与预期不符的情况.

4. **如果要存储用户的密码散列, 应该使用什么字段进行存储?**

密码散列,盐,用户身份证号等固定长度的字符串应该使用char而不是varchar来存储,这样可以节省空间且提高检索效率.

### 1.4 存储引擎相关

1. **MySQL支持哪些存储引擎?**

MySQL支持多种存储引擎,比如InnoDB,MyISAM,Memory,Archive等等.在大多数的情况下,直接选择使用InnoDB引擎都是最合适的,InnoDB也是MySQL的默认存储引擎.

InnoDB和MyISAM有什么区别?
InnoDB支持事务，而MyISAM不支持事物，崩溃后无法安全恢复，表锁非常影响性能
InnoDB支持行级锁，而MyISAM支持表级锁
InnoDB支持MVCC，实现了四个标准的隔离级别 而MyISAM不支持
InnoDB 表是基于聚族索引建立的，聚族索引对主键查询有很高的性能
InnoDB支持外键，而MyISAM不支持
InnoDB不支持全文索引，而MyISAM支持，可以支持复杂的查询（注意：5.6版本之后InnoDB存储引擎开始支持全文索引,5.7版本之后通过使用ngram插件开始支持中文）
零散问题

1. **MySQL中的varchar和char有什么区别.**

char是一个定长字段,假如申请了char(10)的空间,那么无论实际存储多少内容.该字段都占用10个字符,而varchar是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.

在检索效率上来讲,char > varchar,因此在使用中,如果确定某个字段的值的长度,可以使用char,否则应该尽量使用varchar.例如存储用户MD5加密后的密码,则应该使用char.

2. **varchar(10)和int(10)代表什么含义?**

varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度,而int的10只是代表了展示的长度,不足10位以0填充.也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.

3. **MySQL的binlog有有几种录入格式?分别有什么区别?**

有三种格式,statement,row和mixed.

statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.
row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.
mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.
此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.

4. **超大分页怎么处理?**

超大的分页一般从两个方向上来解决.

数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age > 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age > 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id > 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.
从需求的角度减少这种请求....主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.
解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.

在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.

2019-07-18-11-46-19

5. **关心过业务系统里面的sql耗时吗? 统计过慢查询吗?对慢查询都怎么优化过?**

在业务系统中,除了使用主键进行的查询,其他的我都会在测试库上测试其耗时,慢查询的统计主要由运维在做,会定期将业务中的慢查询反馈给我们.

慢查询的优化首先要搞明白慢的原因是什么? 是查询条件没有命中索引?是load了不需要的数据列?还是数据量太大?

所以优化也是针对这三个方向来的,

首先分析语句,看看是否load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写.
分析语句的执行计划,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引.
如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表.

6. **上面提到横向分表和纵向分表,可以分别举一个适合他们的例子吗?**

横向分表是按行分表.假设我们有一张用户表,主键是自增ID且同时是用户的ID.数据量较大,有1亿多条,那么此时放在一张表里的查询效果就不太理想.我们可以根据主键ID进行分表,无论是按尾号分,或者按ID的区间分都是可以的. 假设按照尾号0-99分为100个表,那么每张表中的数据就仅有100w.这时的查询效率无疑是可以满足要求的.

纵向分表是按列分表.假设我们现在有一张文章表.包含字段id-摘要-内容.而系统中的展示形式是刷新出一个列表,列表中仅包含标题和摘要,当用户点击某篇文章进入详情时才需要正文内容.此时,如果数据量大,将内容这个很大且不经常使用的列放在一起会拖慢原表的查询速度.我们可以将上面的表分为两张.id-摘要,id-内容.当用户点击详情,那主键再来取一次内容即可.而增加的存储量只是很小的主键字段.代价很小.

当然,分表其实和业务的关联度很高,在分表之前一定要做好调研以及benchmark.不要按照自己的猜想盲目操作.

7. **什么是存储过程？ 有哪些优缺点？**

存储过程是一些预编译的SQL语句。
1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。
2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全

但是,在互联网项目中,其实是不太推荐存储过程的,比较出名的就是阿里的《Java开发手册》中禁止使用存储过程,我个人的理解是,在互联网项目中,迭代太快,项目的生命周期也比较短,人员流动相比于传统的项目也更加频繁,在这样的情况下,存储过程的管理确实是没有那么方便,同时,复用性也没有写在服务层那么好.

8. **说一说三个范式**

- 第一范式: 每个列都不可以再拆分.
- 第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分.
- 第三范式: 非主键列只依赖于主键,不依赖于其他非主键.

在设计数据库结构的时候,要尽量遵守三范式,如果不遵守,必须有足够的理由.比如性能. 事实上我们经常会为了性能而妥协数据库的设计.

9. **MyBatis中的#和$有什么区别?**

乱入了一个奇怪的问题.....我只是想单独记录一下这个问题,因为出现频率太高了.

#### 会将传入的内容当做字符串,而$会直接将传入值拼接在sql语句中.

所以#可以在一定程度上预防sql注入攻击

```
LEFT JOIN 、RIGHT JOIN、INNER JOIN
LEFT JOIN(左连接)：获取左表所有记录，即使右表没有对应匹配的记录
RIGHT JOIN(右连接)： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录
INNER JOIN(内连接)：获取两个表中字段匹配关系的记录
UNION、UNION ALL
UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据
UNION ALL 操作符重复数据全部显示，不去重
常用 MySQL 函数
```

`数学函数`
```
floor(x) 返回不大于 x 的最大整数值
ceil/ceiling(x) 返回不小于 x 的最小整数
round(x) 四舍五入
rand() 随机函数[0, 1)
abs(x) 返回 x 的绝对值
```

`字符串函数`
```
concat(str1, str2, ...) 将参数连接成字符串返回
length(str) 返回字符串长度
```

`日期和时间函数`
```
now() 当前时间
curdate() 当前日期
SELECT UNIX_TIMESTAMP('2019-05-07 22:55:00'); #1557240900
SELECT FROM_UNIXTIME(1557240900); #2019-05-07 22:55:00
```

`系统信息函数`
```
VERSION() 返回数据库的版本号
LAST_INSERT_ID() 返回最后生成的 AUTO_INCREMENT 值
```

`加密函数`
```
PASSWORD(str) 对字符串 str 进行加密
MD5(str) 对字符串 str 进行加密
```

`格式化函数`

```
FORMAT(x, n) 可以将数字 x 进行格式化，保留到小数点后 n 位，四舍五入
SELECT FORMAT(2.7895, 2); #2.79
```

`获取当前时间（年月日时分秒）`
```
mysql> select now();
+---------------------+
| now()               |
+---------------------+
| 2020-05-22 10:39:23 |
+---------------------+
```

`获取当前时间戳`

```
mysql> select unix_timestamp(now());
+-----------------------+
| unix_timestamp(now()) |
+-----------------------+
|            1590115200 |
+-----------------------+
1 row in set (0.00 sec)
```

`获取年月日`

```
mysql> SELECT CURDATE(); 
+------------+
| CURDATE()  |
+------------+
| 2020-05-22 |
+------------+
1 row in set (0.00 sec)
sql的left join 、right join 、inner join之间的区别
left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 
right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
inner join(等值连接) 只返回两个表中联结字段相等的行
```

#### `char和varchar 的区别`

主要区别

`1、char的长度是不可变的，而varchar的长度是可变的`

```
字段b：类型char(10)，     值为：abc，存储为：abc  （abc+7个空格）
字段d：类型varchar(10)， 值为：abc，存储为：abc （自动变为3个的长度）
```

`2、超出长度自动截取`

```
字段c：类型char(3)，     值为：abcdefg，存储为：abc（defg自动删除）

字段e：类型varchar(3)， 值为：abcdefg，存储为：abc （defg自动删除）
```

`3、var(10)和char(10)，都表示可存10个字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放10个`

`4、char最多可以存放255个字符`

varchar的最大长度为65535个字节，varchar可存放的字符数跟编码有关

字符类型若为gbk，每个字符最多占2个字节，最大长度不能超过32766个字符

字符类型若为utf8，每个字符最多占3个字节，最大长度不能超过21845个字符

`5、char和varchar的最大长度限制是mysql规定的`

深度剖析
`在MySQL数据库中，用的最多的字符型数据类型就是Varchar和Char`.。这两种数据类型虽然都是用来存放字符型数据，但是无论从结构还是从数据的保存方式来看，两者相差很大。而且其具体的实现方式，还依赖与存储引擎。这里就以大家最常用的MYISAM存储引擎为例，谈谈这两种数据类型的差异。

这里首先需要明白的一点是，这两种数据类型，无论采用哪一种存储引起，系统存储数据的方式都是不同的。正是因为如此，我们才有必要研究两者的不同。然后在合适的情况下，采用恰当的方式。

Varchar往往用来保存可变长度的字符串。简单的说，我们只是给其固定了一个最大值，然后系统会根据实际存储的数据量来分配合适的存储空间。为此相比CHAR字符数据而言，其能够比固定长度类型占用更少的存储空间。不过在实际工作中，由于某系特殊的原因，会在这里设置例外。如管理员可以根据需要指定ROW_FORMAT=FIXED选项。利用这个选项来创建MyISAM表的话，系统将会为每一行使用固定长度的空间。此时会造成存储空间的损耗。通常情况下，VARCHAR数据类型能够节约磁盘空间，为此往往认为其能够提升数据库的性能。不过这里需要注意的是，这往往是一把双刃剑。其在提升性能的同时，往往也会产生一些副作用。如因为其长度是可变的，为此在数据进行更新时可能会导致一些额外的工作。如在更改前，其字符长度是10位(Varchar规定的最长字符数假设是50位)，此时系统就只给其分配10个存储的位置(假设不考虑系统自身的开销)。更改后，其数据量达到了20位。由于没有超过最大50位的限制，为此数据库还是允许其存储的。只是其原先的存储位置已经无法满足其存储的需求。此时系统就需要进行额外的操作。如根据存储引擎不同，有的会采用拆分机制，而有的则会采用分页机制。

CHAR数据类型与VARCHAR数据类型不同，其采用的是固定长度的存储方式。简单的说，就是系统总为其分配最大的存储空间。当数据保存时，即使其没有达到最大的长度，系统也会为其分配这么多的存储空间。显然，这种存储方式会造成磁盘空间的浪费。这里笔者需要提醒的一点是，当字符位数不足时，系统并不会采用空格来填充。相反，如果在保存CHAR值的时候，如果其后面有空值，系统还会自动过滤其空格。而在进行数据比较时，系统又会将空格填充到字符串的末尾。

显然，VARCHAR与CHAR两种字符型数据类型相比，最大的差异就是前者是可变长度，而后者则是固定长度。在存储时，前者会根据实际存储的数据来分配最终的存储空间。而后者则不管实际存储数据的长度，都是根据CHAR规定的长度来分配存储空间。这是否意味着CHAR的数据类型劣于VARCHAR呢?其实不然。否则的话，就没有必要存在CHAR字符类型了。虽然VARCHAR数据类型可以节省存储空间，提高数据处理的效率。但是其可变长度带来的一些负面效应，有时候会抵消其带来的优势。为此在某些情况下，还是需要使用Char数据类型。

注意：使用Varchar数据类型，也不能够太过于慷慨。这是什么意思呢?如现在用户需要存储一个地址信息。根据评估，只要使用100个字符就可以了。但是有些数据库管理员会认为，反正Varchar数据类型是根据实际的需要来分配长度的。还不如给其大一点的呢。为此他们可能会为这个字段一次性分配200个字符的存储空间。这VARCHAR(100)与VARCHAR(200)真的相同吗?结果是否定的。虽然他们用来存储90个字符的数据，其存储空间相同。但是对于内存的消耗是不同的。对于VARCHAR数据类型来说，硬盘上的存储空间虽然都是根据实际字符长度来分配存储空间的，但是对于内存来说，则不是。其时使用固定大小的内存块来保存值。简单的说，就是使用字符类型中定义的长度，即200个字符空间。显然，这对于排序或者临时表(这些内容都需要通过内存来实现)作业会产生比较大的不利影响。所以如果某些字段会涉及到文件排序或者基于磁盘的临时表时，分配VARCHAR数据类型时仍然不能够太过于慷慨。还是要评估实际需要的长度，然后选择一个最长的字段来设置字符长度。如果为了考虑冗余，可以留10%左右的字符长度。千万不能认为其为根据实际长度来分配存储空间，而随意的分配长度，或者说干脆使用最大的字符长度。

适用情况
1、对于MyISAM表，尽量使用Char，对于那些经常需要修改而容易形成碎片的myisam和isam数据表就更是如此，它的缺点就是占用磁盘空间；

2、对于InnoDB表，因为它的数据行内部存储格式对固定长度的数据行和可变长度的数据行不加区分（所有数据行共用一个表头部分，这个标头部分存放着指向各有关数据列的指针），所以使用char类型不见得会比使用varchar类型好。事实上，因为char类型通常要比varchar类型占用更多的空间，所以从减少空间占用量和减少磁盘i/o的角度，使用varchar类型反而更有利；

3、存储很短的信息，比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的现在得不偿失。

4、固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。

5、十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。

---

## 2.`MySQL高性能优化规范`

### 2.1 数据库命令规范
• 所有数据库对象名称必须使用小写字母并用下划线分割

• 所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）

• 数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符

• 临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀

• 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）

### 2.2 数据库基本设计规范

1. **所有表必须使用 Innodb 存储引擎**
没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。

Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。

2. **数据库和表的字符集统一使用 UTF8**
兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。

3. **所有表和字段都需要添加注释**
使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护

4. **尽量控制单表数据量的大小, 建议控制在 500 万以内。**
500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。

可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小

5. **谨慎使用 MySQL 分区表**
分区表在物理上表现为多个文件，在逻辑上表现为一个表；

谨慎选择分区键，跨分区查询效率可能更低；

建议采用物理分表的方式管理大数据。

6.**尽量做到冷热数据分离,减小表的`宽度`**

MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。

减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）；

更有效的利用缓存，避免读入无用的冷数据；

经常一起使用的列放到一个表中（避免更多的关联操作）。

7. **禁止在表中建立预留字段**
预留字段的命名很难做到见名识义。

预留字段无法确认存储的数据类型，所以无法选择合适的类型。

对预留字段类型的修改，会对表进行锁定。

8. **禁止在数据库中存储图片, 文件等大的二进制数据**
通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。

通常存储于文件服务器，数据库只存储文件地址信息

9. **禁止在线上做数据库压力测试**

10. **禁止从开发环境, 测试环境直接连接生成环境数据库**

### 数据库字段设计规范

1. **优先选择符合存储需要的最小的数据类型**

**原因**：

列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。

**方法**：

a.将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据

MySQL 提供了两个方法来处理 ip 地址

•inet_aton 把 ip 转为无符号整型 (4-8 位)•inet_ntoa 把整型的 ip 转为地址

插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间，显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。

b.对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储

原因：

无符号相对于有符号可以多出一倍的存储空间

SIGNED INT -2147483648~2147483647
VARCHAR(N) 中的 N 代表的是字符数，而不是字节数，使用 UTF8 存储 255 个汉字 Varchar(255)=765 个字节。过大的长度会消耗更多的内存。

2. **避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据**

a. `建议把 BLOB 或是 TEXT 列分离到单独的扩展表中`

`MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型`，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。
而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是`不是说一定不能使用`这样的数据类型。

如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。

2、TEXT 或 BLOB 类型只能使用前缀索引

因为MySQL[1] 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的

3. **避免使用 ENUM 类型**
修改 ENUM 值需要使用 ALTER 语句

ENUM 类型的 ORDER BY 操作效率低，需要额外操作

禁止使用数值作为 ENUM 的枚举值

4. **尽可能把所有列定义为 NOT NULL**

**原因**：

`索引 NULL 列需要额外的空间来保存，所以要占用更多的空间`

进行比较和计算时要对 NULL 值做特别的处理

5. **使用 `TIMESTAM`P(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间**

TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ `2038-01-19-03:14:07`

`TIMESTAMP 占用 4 字节和 INT 相同`，但比 `INT 可读性高`

超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储

经常会有人用字符串存储日期型的数据（不正确的做法）

•缺点 1：无法用日期函数进行计算和比较•缺点 2：用字符串存储日期要占用更多的空间

6. **同财务相关的金额类数据必须使用 decimal 类型**

•非精准浮点：float,double•精准浮点：decimal

Decimal 类型为精准浮点数，在计算时不会丢失精度

占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节

可用于存储比 bigint 更大的整型数据

### 2.3 索引设计规范

1. **限制每张表上的索引数量, 建议单张表索引不超过 `5 个`**
索引并不是越多越好！索引可以提高效率同样可以降低效率。

索引可以增加查询效率，但同样也会`降低插入和更新的效率`，甚至有些情况下会降低查询效率。

因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。

2. **禁止给表中的每一列都建立单独的索引**
5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。

3. **每个 Innodb 表必须有个主键**
Innodb 是一种`索引组织表`：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。

Innodb 是按照主键索引的顺序来组织表的

•`不要使用更新频繁的列作为主键`，不适用多列主键（相当于联合索引）•不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）•主键建议使用自增 ID 值

4. **常见索引列建议**
•出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列•包含在 ORDER BY、GROUP BY、DISTINCT 中的字段•并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好•多表 join 的关联列

5. **如何选择索引列的顺序**
建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。

•区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）•尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）•使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）

6. **避免建立冗余索引和重复索引**（增加了查询优化器生成执行计划的时间）
•重复索引示例：primary key(id)、index(id)、unique index(id)•冗余索引示例：index(a,b,c)、index(a,b)、index(a)

7. **对于频繁的查询优先考虑使用覆盖索引**
覆盖索引：就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引

覆盖索引的好处：

•避免 Innodb 表进行索引的`二次查询`: Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。•可以把随机 IO 变成顺序 IO 加快查询效率: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。

8. **索引 SET 规范**
尽量避免使用外键约束

•不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引•外键可用于保证数据的参照完整性，但建议在业务端实现•外键会影响父表和子表的写操作从而降低性能

### 2.4 数据库 SQL 开发规范

1. **建议使用预编译语句进行数据库操作**
预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。

只传参数，比传递 SQL 语句更高效。

相同语句可以一次解析，多次使用，提高处理效率。

2. **避免数据类型的隐式转换**

隐式转换会导致索引失效如:

select name,phone from customer where id = '111';

3. **充分利用表上已经存在的索引**
避免使用双%号的查询条件。如：a like '%123%'，（如果无前置%,只有后置%，是可以用到列上的索引的）

一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。

在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。

4. **数据库设计时，应该要对以后扩展进行考虑**

5. **程序连接不同的数据库使用不同的账号，进制跨库查询**
•为数据库迁移和分库分表留出余地•降低业务耦合度•避免权限过大而产生的安全风险

6. **禁止使用 SELECT * 必须使用 SELECT 查询**
原因：

•消耗更多的 CPU 和 IO 以网络带宽资源•无法使用覆盖索引•可减少表结构变更带来的影响

7. **禁止使用不含字段列表的 INSERT 语句**
如：

insert into values ('a','b','c');
应使用：

insert into t(c1,c2,c3) values ('a','b','c');

8. **避免使用子查询，可以把子查询优化为 join 操作**
通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。

子查询性能差的原因：

子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。

由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。

9. **避免使用 JOIN 关联太多的表**
对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。

在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。

如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。

同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，`建议不超过 5 个`。

10. **减少同数据库的交互次数**
数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。

11. **对应同一列进行 or 判断时，使用 in 代替 or**
in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。

12. **禁止使用 order by rand() 进行随机排序**
order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。

推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。

13. **WHERE 从句中禁止对列进行函数转换和计算**
对列进行函数转换或计算时会`导致无法使用索引`

不推荐：

where date(create_time)='20190101'
推荐：

where create_time >= '20190101' and create_time < '20190102'

14. **在明显不会有重复值时使用 UNION ALL 而不是 UNION**
•UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作•UNION ALL 不会再对结果集进行去重操作

15. **拆分复杂的大 SQL 为多个小 SQL**
•大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL•MySQL 中，一个 SQL 只能使用一个 CPU 进行计算•SQL 拆分后可以通过并行执行来提高处理效率


### 2.5 数据库操作行为规范
1. **超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作**
大批量操作可能会造成严重的`主从延迟`

主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况

binlog 日志为 row 格式时会产生大量的日志

大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因

避免产生大事务操作

大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。

特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批

2. **对于大表使用 pt-online-schema-change 修改表结构**

•避免大表修改产生的主从延迟•避免在对表字段进行修改时进行锁表

`对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的`。

pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。

3. **禁止为程序使用的账号赋予 super 权限**
•当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接•super 权限只能留给 `DBA` 处理问题的账号使用

4. 对于程序连接数据库账号,遵循权限最小原则
•程序使用数据库账号只能在一个 DB 下使用，不准跨库•程序使用的账号原则上不准有 drop 权限

## 3.`MySQL Explain执行计划` - 详解

### 3.1 Explain有什么用
当Explain与SQL语句一起使用时，MySQL会显示来自优化器关于SQL执行的信息。也就是说，MySQL解释了它将如何处理该语句，包括如何连接表以及什么顺序连接表等。

表的加载顺序
sql的查询类型
可能用到哪些索引，哪些索引又被实际使用
表与表之间的引用关系
一个表中有多少行被优化器查询
.....

### 3.2 Explain有哪些信息
Explain执行计划包含字段信息如下：分别是id、select_type、table、partitions、type、possible_keys、key、key_len、ref、rows、filtered、Extra12个字段。

下边我们会结合具体的SQL示例，详细的解读每个字段以及每个字段中不同参数的含义，以下所有示例数据库版本为MySQL.5.7.17。

```
mysql> select version() from dual;
+------------+
| version()  |
+------------+
| 5.7.17-log |
+------------+
```

我们创建三张表one、two、three，表之间的关系one.two_id = two.two_id AND two.three_id = three.three_id。

Explain执行计划详解
一、id
id：：表示查询中执行select子句或者操作表的顺序，id的值越大，代表优先级越高，越先执行。id大致会出现 3种情况：

1、id相同
看到三条记录的id都相同，可以理解成这三个表为一组，具有同样的优先级，执行顺序由上而下，具体顺序由优化器决定。

```
mysql> EXPLAIN SELECT * FROM one o,two t, three r WHERE o.two_id = t.two_id AND t.three_id = r.three_id;
+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                  | rows | filtered | Extra                                              |
+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+
|  1 | SIMPLE      | o     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL                 |    2 |      100 | NULL                                               |
|  1 | SIMPLE      | t     | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL                 |    2 |       50 | Using where; Using join buffer (Block Nested Loop) |
|  1 | SIMPLE      | r     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xin-slave.t.three_id |    1 |      100 | NULL                                               |
+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+
```

2、id不同
如果我们的SQL中存在子查询，那么id的序号会递增，id值越大优先级越高，越先被执行 。当三个表依次嵌套，发现最里层的子查询id最大，最先执行。

```
mysql> EXPLAIN select * from one o where o.two_id = (select t.two_id from two t where t.three_id = (select r.three_id  from three r where r.three_name='我是第三表2'));
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | PRIMARY     | o     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using where |
|  2 | SUBQUERY    | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using where |
|  3 | SUBQUERY    | r     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
```
3. 以上两种同时存在

将上边的SQL稍微修改一下，增加一个子查询，发现id的以上两种同时存在。相同id划分为一组，这样就有三个组，同组的从上往下顺序执行，不同组id值越大，优先级越高，越先执行。

```
mysql>  EXPLAIN select * from one o where o.two_id = (select t.two_id from two t where t.three_id = (select r.three_id  from three r where r.three_name='我是第三表2')) AND o.one_id in(select one_id from one where o.one_name="我是第一表2");

+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                | rows | filtered | Extra       |
+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+
|  1 | PRIMARY     | o     | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL               |    2 |       50 | Using where |
|  1 | PRIMARY     | one   | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xin-slave.o.one_id |    1 |      100 | Using index |
|  2 | SUBQUERY    | t     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL               |    2 |       50 | Using where |
|  3 | SUBQUERY    | r     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL               |    2 |       50 | Using where |
+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+
```

#### 二、`select_type`
select_type：表示select查询的类型，主要是用于区分各种复杂的查询，例如：普通查询、联合查询、子查询等。

1、`SIMPLE`
SIMPLE：表示最简单的 select 查询语句，也就是在查询中不包含子查询或者union交并差集等操作。

2、`PRIMARY`
PRIMARY：当查询语句中包含任何复杂的子部分，最外层查询则被标记为PRIMARY。

3、`SUBQUERY`
SUBQUERY：当select或where列表中包含了子查询，该子查询被标记为：SUBQUERY。

4、`DERIVED`
DERIVED：表示包含在from子句中的子查询的select，在我们的from列表中包含的子查询会被标记为derived。

5、`UNION`
UNION：如果union后边又出现的select语句，则会被标记为union；若union包含在from子句的子查询中，外层select将被标记为derived。

6、UNION RESULT
UNION RESULT：代表从union的临时表中读取数据，而table列的<union1,4>表示用第一个和第四个select的结果进行union操作。

```
mysql> EXPLAIN select t.two_name, ( select one.one_id from one) o from (select two_id,two_name from two where two_name ='') t  union (select r.three_name,r.three_id from three r);

+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+
| id   | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |
+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+
|    1 | PRIMARY      | two        | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |    2 |       50 | Using where     |
|    2 | SUBQUERY     | one        | NULL       | index | NULL          | PRIMARY | 4       | NULL |    2 |      100 | Using index     |
|    4 | UNION        | r          | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |    2 |      100 | NULL            |
| NULL | UNION RESULT | <union1,4> | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL | NULL     | Using temporary |
+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+
```

#### 三、table
查询的表名，并不一定是真实存在的表，有别名显示别名，也可能为临时表，例如上边的DERIVED、<union1,4>等。

#### 四、partitions
查询时匹配到的分区信息，对于非分区表值为NULL，当查询的是分区表时，partitions显示分区表命中的分区情况。

```
+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table          | partitions                      | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | one            | p201801,p201802,p201803,p300012 | index | NULL          | PRIMARY | 9       | NULL |    3 |      100 | Using index |
+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+
```

### 五、`type`(重中之重)
type：查询使用了何种类型，它在SQL优化中是一个非常重要的指标，以下性能从好到坏依次是：
`system > const > eq_ref > ref > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL`

- 1. `system`
system： 当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘IO，速度非常快。

- 2. `const`
const：表示查询时命中primary key主键或者unique唯一索引，或者被连接的部分是一个常量(const)值。这类扫描效率极高，返回数据量少，速度非常快。

```
mysql> EXPLAIN SELECT * from three where three_id=1;
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | three | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |      100 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
```

- 3. `eq_ref`
eq_ref：查询时命中主键primary key或者unique key索引，type就是eq_ref。

```
mysql> EXPLAIN select o.one_name from one o ,two t where o.one_id = t.two_id ; 
+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+
| id | select_type | table | partitions | type   | possible_keys | key      | key_len | ref                | rows | filtered | Extra       |
+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+
|  1 | SIMPLE      | o     | NULL       | index  | PRIMARY       | idx_name | 768     | NULL               |    2 |      100 | Using index |
|  1 | SIMPLE      | t     | NULL       | eq_ref | PRIMARY       | PRIMARY  | 4       | xin-slave.o.one_id |    1 |      100 | Using index |
+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+
```

- 4. `ref`
ref：区别于eq_ref，ref表示使用非唯一性索引，会找到很多个符合条件的行。

```
mysql> select o.one_id from one o where o.one_name = "xin" ; 
+--------+
| one_id |
+--------+
|      1 |
|      3 |
+--------+

mysql> EXPLAIN select o.one_id from one o where o.one_name = "xin" ; 
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | o     | NULL       | ref  | idx_name      | idx_name | 768     | const |    1 |      100 | Using index |
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+
```
- 5. `ref_or_null`
ref_or_null：这种连接类型类似于 ref，区别在于MySQL会额外搜索包含NULL值的行。

```
mysql> EXPLAIN select o.one_id from one o where o.one_name = "xin" OR o.one_name IS NULL; 
+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+
| id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+
|  1 | SIMPLE      | o     | NULL       | ref_or_null | idx_name      | idx_name | 768     | const |    3 |      100 | Using where; Using index |
+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+
```

- 6. `index_merge`
index_merge：使用了索引合并优化方法，查询使用了两个以上的索引。

下边示例中同时使用到主键one_id和 字段one_name的idx_name索引 。

```
mysql> EXPLAIN select * from one o where o.one_id >1 and o.one_name ='xin'; 
+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+
| id | select_type | table | partitions | type        | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                                          |
+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+
|  1 | SIMPLE      | o     | NULL       | index_merge | PRIMARY,idx_name | idx_name,PRIMARY | 772,4   | NULL |    1 |      100 | Using intersect(idx_name,PRIMARY); Using where |
+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+
```

- 7. `unique_subquery`
unique_subquery：替换下面的IN子查询，子查询返回不重复的集合。
```
value IN (SELECT primary_key FROM single_table WHERE some_expr)
```

- 8. `index_subquery`
index_subquery：区别于unique_subquery，用于非唯一索引，可以返回重复值。

value IN (SELECT key_column FROM single_table WHERE some_expr)

- 9. `range`
range：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在where语句中使用bettween...and、<、>、<=、in等条件查询type都是range。

举个栗子：three表中three_id为唯一主键，user_id普通字段未建索引。

```
mysql> EXPLAIN SELECT * from three where three_id BETWEEN 2 AND 3;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | three | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    1 |      100 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
```

从结果中看到只有对设置了索引的字段，做范围检索type才是range。
```
mysql> EXPLAIN SELECT * from three where user_id BETWEEN 2 AND 3;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | three | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
```

- 10. `index`
index：Index与ALL其实都是读全表，区别在于index是遍历索引树读取，而ALL是从硬盘中读取。

下边示例：three_id为主键，不带where条件全表查询 ，type结果为index。

```
mysql> EXPLAIN SELECT three_id from three ;

+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | three | NULL       | index | NULL          | PRIMARY | 4       | NULL |    1 |      100 | Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
```

- 11. `ALL`

ALL：将遍历`全表`以找到匹配的行，性能最差。
```
mysql> EXPLAIN SELECT * from two ;

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | two   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |      100 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
```

#### 六、possible_keys
possible_keys：表示在MySQL中通过哪些索引，能让我们在表中找到想要的记录，一旦查询涉及到的某个字段上存在索引，则索引将被列出，但这个索引并不定一会是最终查询数据时所被用到的索引。具体请参考上边的例子。

#### 七、key
key：区别于possible_keys，key是查询中实际使用到的索引，若没有使用索引，显示为NULL。具体请参考上边的例子。

当type为index_merge时，可能会显示多个索引。

#### 八、key_len
key_len：表示查询用到的索引长度（字节数），原则上长度越短越好 。

单列索引，那么需要将整个索引长度算进去；
多列索引，不是所有列都能用到，需要计算查询中实际用到的列。
注意：key_len只计算where条件中用到的索引长度，而排序和分组即便是用到了索引，也不会计算到key_len中。

#### 九、ref
ref：常见的有：const，func，null，字段名。

当使用常量等值查询，显示const，
当关联查询时，会显示相应关联表的关联字段
如果查询条件使用了表达式、函数，或者条件列发生内部隐式转换，可能显示为func
其他情况null

#### 十、rows
rows：以表的统计信息和索引使用情况，估算要找到我们所需的记录，需要读取的行数。

这是评估SQL性能的一个比较重要的数据，mysql需要扫描的行数，很直观的显示SQL性能的好坏，一般情况下rows值越小越好。

```
mysql> EXPLAIN SELECT * from three;

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | three | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
```

#### 十一、filtered
filtered这个是一个百分比的值，表里符合条件的记录数的百分比。简单点说，这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例。

在MySQL.5.7版本以前想要显示filtered需要使用explain extended命令。MySQL.5.7后，默认explain直接显示partitions和filtered的信息。

####十二、Extra
Extra：不适合在其他列中显示的信息，Explain中的很多额外的信息会在Extra字段显示。

1、Using index
Using index：我们在相应的select操作中使用了覆盖索引，通俗一点讲就是查询的列被索引覆盖，使用到覆盖索引查询速度会非常快，SQl优化中理想的状态。

### 3.4 什么又是`覆盖索引`?

一条SQL只需要通过索引就可以返回，我们所需要查询的数据（一个或几个字段），而不必通过二级索引，查到主键之后再通过主键查询整行数据（select *）。

one_id表为主键
```
mysql> EXPLAIN SELECT one_id from one ;

+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | one   | NULL       | index | NULL          | idx_two_id | 5       | NULL |    3 |      100 | Using index |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
```

注意：想要使用到覆盖索引，我们在select时只取出需要的字段，不可select *，而且该字段建了索引。
```
mysql> EXPLAIN SELECT * from one ;

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
```

- 2、Using where
Using where：查询时未找到可用的索引，进而通过where条件过滤获取所需数据，但要注意的是并不是所有带where语句的查询都会显示Using where。

下边示例create_time并未用到索引，type为ALL，即MySQL通过全表扫描后再按where条件筛选数据。
```
mysql> EXPLAIN SELECT one_name from one where create_time ='2020-05-18';

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
```

- 3、Using temporary
Using temporary：表示查询后结果需要使用临时表来存储，一般在排序或者分组查询时用到。

```
mysql> EXPLAIN SELECT one_name from one where one_id in (1,2) group by one_name;

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | one   | NULL       | range| NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where; Using temporary; Using filesort |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
```

- 4、Using filesort
Using filesort：表示无法利用索引完成的排序操作，也就是ORDER BY的字段没有索引，通常这样的SQL都是需要优化的。

```
mysql> EXPLAIN SELECT one_id from one  ORDER BY create_time;

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | Using filesort |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
```

如果ORDER BY字段有索引就会用到覆盖索引，相比执行速度快很多。
```
mysql> EXPLAIN SELECT one_id from one  ORDER BY one_id;

+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | one   | NULL       | index | NULL          | PRIMARY | 4       | NULL |    3 |      100 | Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
```

- 5、Using join buffer
Using join buffer：在我们联表查询的时候，如果表的连接条件没有用到索引，需要有一个连接缓冲区来存储中间结果。

先看一下有索引的情况：连接条件one_name、two_name都用到索引。
```
mysql> EXPLAIN SELECT one_name from one o,two t where o.one_name = t.two_name;

+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref                  | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+
|  1 | SIMPLE      | o     | NULL       | index | idx_name      | idx_name | 768     | NULL                 |    3 |      100 | Using where; Using index |
|  1 | SIMPLE      | t     | NULL       | ref   | idx_name      | idx_name | 768     | xin-slave.o.one_name |    1 |      100 | Using index              |
+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+
```

接下来删掉 连接条件one_name、two_name的字段索引。发现Extra列变成Using join buffer，type均为全表扫描，这也是SQL优化中需要注意的地方。
```
mysql> EXPLAIN SELECT one_name from one o,two t where o.one_name = t.two_name;

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
|  1 | SIMPLE      | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |      100 | NULL                                               |
|  1 | SIMPLE      | o     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
```

- 6、Impossible where
Impossible where：表示在我们用不太正确的where语句，导致没有符合条件的行。

```
mysql> EXPLAIN SELECT one_name from one WHERE 1=2;

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL     | Impossible WHERE |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
```

- 7、No tables used
No tables used：我们的查询语句中没有FROM子句，或者有FROM DUAL子句。

```
mysql> EXPLAIN select now();

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL     | No tables used |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
```
Extra列的信息非常非常多，这里就不再一一列举了，详见MySQL官方文档 ：https://dev.mysql.com/doc/ref...



### 3.5 总结
重点看的几列：

possible_keys：可能可以利用的索引的名字。这里的索引名字是创建索引时指定的索引昵称；如果索引没有昵称，则默认显示的是索引中第一个列的名字（在本例中，它是“firstname”）。默认索引名字的含义往往不是很明显。

key：它显示了MySQL实际使用的索引的名字。如果它为空（或NULL），则MySQL不使用索引。

key_len：索引中被使用部分的长度，以字节计

ref：列出是通过常量（const），还是某个表的某个字段（如果是join）来过滤（通过key）
的；

rows：MySQL所认为的它在找到正确的结果之前必须扫描的记录数。显然，这里最理想的数字就是1。

---

## 4.`MySQL查询优化`-详解

### 4.1 SQL通用优化方案:
1. 使用参数化查询：防止SQL注入，预编译SQL命令提高效率
2. 去掉不必要的查询和搜索字段：其实在项目的实际应用中，很多查询条件是可有可无的，能从源头上避免的多余功能尽量砍掉，这是最简单粗暴的解决方案。
3. 选择最有效率的表名顺序: 数据库的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表放在最后，如果有3个以上的表连接查询,那就需要选择那个被其他表所引用的表放在最后。
4. 不要使用select *：不要使用select *，以提高查询效率，减少输出的数据量，提高传输速度（数据库或在解析过程中将"*"依次转换成所有列名，这意味着消耗更多的时间）
5. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
6. 减少访问数据库的次数：通过存储过程等，把多条语句放在一个存储过程中执行，减少数据库访问次数
7. 整合简单的、无关联的数据库访问：如果你有几个简单的数据库查询语句,你可以把它们整合到一个查询中(即使它们之间没有关系)）
8. 删除重复记录：删除重复记录，减少数据库文件大小
9. 使用表的别名(Alias)：当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误.
10. 使用列的别名：当列的名称很长的时候，使用简短的列的别名可以查询结果更清晰，更简洁。
11. 用EXISTS替代IN、用NOT EXISTS替代NOT IN：无论在哪种情况下,NOT IN都是最低效的 (因为它对子查询中的表执行了一个全表遍历). 为了避免使用NOT IN ,我们可以把它改写成外连接(Outer Joins)或NOT EXISTS.
12. 统计相关的查询，影响结果集往往巨大，应避免在业务高峰期执行统计相关的查询，或者仅在从库中执行统计查询。同时建议把数据先保存在内存、缓存中(如redis)，再按一定策略写入数据库。
13. select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的，可以用其他方法代替。
14. 使用truncate代替delete清空整个数据表：当删除表中的记录时,在通常情况下, 回滚段(rollback segments ) 用来存放可以被恢复的信息. (可以恢复到执行删除命令之前的状态) 而当运用TRUNCATE时, 回滚段不再存放任何可被恢复的信息.当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短.

### 4.2 字段类型优化：
1. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。
2. 最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.（备注、描述、评论之类的可以设置为 NULL）

### 4.3 where条件语句优化：
1. WHERE子句中的连接顺序：数据库采用自右而左的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前(左), 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾(右).
2. 避免在where语句中出现字段的类型转换（字段的类型和传入的参数类型不一致的时候发生的隐式类型转换）
3. 不要在where条件语句中的"="左边进行函数、算数运算或其他表达式运算，可以通过使用冗余字段来替代函数运算，否则系统无法正确使用索引
4. where 子句中对字段进行 null 值判断、包含not、!=、<>等操作符，或like的关键词前加%(like '%关键词')，都无法使用索引，从而引发全表扫描.
5. 使用like进行模糊查询时应注意,除非必要，否则不要在关键词前加%，否则必然导致全表查询

### 4.4 索引优化：
1. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。
2. 用索引提高效率：合理使用索引和复合索引同样能提高效率.但使用索引是有代价的, 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时, 索引本身也会被修改. 这意味着每条记录的INSERT , DELETE , UPDATE将为此多付出4 , 5 次的磁盘I/O . 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.。定期的重构索引是有必要的。
3. 在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用。
4. 要注意索引的维护，周期性重建索引，重新编译存储过程。

### 4.5 分页语句优化：
1. 分页查询的优化。页数比较多的情况下，如limit 10000,10 影响的结果集是10010行，查询速度会比较慢。推荐的解决方案是：先只查询主键select id from table where .. order by .. limit 10000,10(搜索条件和排序请建立索引)，再通过主键去获取数据。
2. 对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。

### 4.6 事务的优化:
1. 尽量使用COMMIT：尽可能在程序中使用commit，这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少，commit每个数据库引擎都不同，sqlserver默认一条sql语句就是一个事务。
2. 尽量避免大事务操作，提高系统并发能力。
3. 只在必要的情况下才使用begin tran：begin tran保证了数据的一致性，可以确保要么几个表都修改成功，要么都不成功，但Begin tran付出的代价是在提交之前，所有SQL语句锁住的资源都不能释放，直到commit掉。Begin tran使用的原则是，在保证数据一致性的前提下，begin tran 套住的SQL语句越少越好！有些情况下可以采用触发器同步数据，不一定要用begin tran。

### 4.7 临时表优化：
1. 避免频繁创建和删除临时表，以减少系统表资源的消耗。
2. 使用“临时表”暂存中间结果：将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。同时也能简化sql语句的复杂度。
3. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。
4. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。
5. 如果临时表的数据量较大，需要建立索引，那么应该将创建临时表和建立索引的过程放在单独一个子存储过程中，这样才能保证系统能够很好的使用到该临时表的索引。
6. 尽量避免使用distinct、order by、group by、having、join、cumpute，因为这些语句会加重tempdb的负担。
7. 慎用大的临时表与其他大表的连接查询和修改，减低系统表负担，因为这种操作会在一条语句中多次使用tempdb的系统表。

### 4.8 游标优化：
1. 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。
2. 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。
3. 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。

**更多优化：**

读写分离、主从备份、日志等

---

## 5.`MySQL锁`-详解

#### 用途
多个查询需要在同一时刻修改数据，会产生并发控制的问题。使用锁可以有效解决这个问题

### 5.1 锁的分类
- 按照锁的粒度划分：`行锁`、`表锁`、`页锁`
- 按照锁的使用方式划分：`共享锁`、`排它锁`（悲观锁的一种实现）
- 还有两种思想上的锁：`悲观锁`、`乐观锁`
- InnoDB中有几种行级锁类型：Record Lock(在索引记录上加锁)、Gap Lock（间隙锁）、Next-key Lock(临键锁)

### 5.2 行锁
​行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。
**行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。有可能会出现死锁的情况。**

行级锁按照使用方式分为`共享锁`和`排他锁`。

#### 5.2.1 共享锁(同一时刻可以同时读取同一个资源)：
#### 5.2.2 排他锁 (一个写锁会阻塞其他的写锁和读锁)：


`共享锁`用法（S锁 读锁）
​ 若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

select ... lock in share mode;
共享锁就是允许多个线程同时获取一个锁，一个锁可以同时被多个线程拥有。

`排它锁`用法（X 锁 写锁）
​ 若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

select ... for update
​ 排它锁，也称作独占锁，一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁。

### 5.3 表锁
​ 表级锁是mysql锁中粒度`最大`的一种锁，表示当前的操作对整张表加锁，资源开销比行锁少，不会出现死锁的情况，但是发生锁冲突的概率很大。被大部分的mysql引擎支持，MyISAM和InnoDB都支持表级锁，但是InnoDB默认的是行级锁。

共享锁用法：

LOCK TABLE table_name [ AS alias_name ] READ
排它锁用法：

LOCK TABLE table_name [AS alias_name][ LOW_PRIORITY ] WRITE
解锁用法：

unlock tables;

### 5.4 页锁
​ 页级锁是MySQL中锁定粒度`介于行级锁和表级锁中间`的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁
。

### 5.5 悲观锁和乐观锁
无论是悲观锁还是乐观锁，都是人们`定义出来的概念`，可以认为是一种思想。其实不仅仅是数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。

针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。

`悲观锁`
MySQL InnoDB中使用`悲观锁`
要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。 set autocommit=0;

```
//0.开始事务            
begin;/begin work;/start transaction; (三者选一就可以)              
//1.查询出商品信息               
select status from t_goods where id=1 for update;              
//2.根据商品信息生成订单                
insert into t_orders (id,goods_id) values (null,1);              
//3.修改商品status为2               
update t_goods set status=2;              
//4.提交事务             
commit;
```

上面的查询语句中，我们使用了 select…for update 的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。

上面我们提到，使用 select…for update 会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。

`优点与不足`
悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。

`乐观锁`
在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。

乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。

数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。

实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳，方法类似，下面举例说明版本号的做法。

使用版本号实现乐观锁
使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据

1.数据库表设计
task表有三个字段，分别是id，value，version

2.实现
1）先读task表的数据（实际上这个表只有一条记录），得到version的值为versionValue

2）每次更新task表中的value字段时，为了防止发生冲突，需要这样操作

```
update task set value = newValue,version =  versionValue + 1   where version = versionValue;
```
只有这条语句执行了，才表明本次更新value字段的值成功

如假设有两个节点A和B都要更新task表中的value字段值，差不多在同一时刻，A节点和B节点从task表中读到的version值为2，那么A节点和B节点在更新value字段值的时候，都操作 update task set value = newValue,version = 3 where version = 2;,实际上只有1个节点执行该SQL语句成功，假设A节点执行成功，那么此时task表的version字段的值是3，B节点再操作update task set value = newValue,version = 3 where version = 2;这条SQL语句是不执行的，这样就保证了更新task表时不发生冲突。

### 5.6 锁粒度
表锁：开销最小，对表进行写操作，需要获得写锁，会阻塞该表的所有读写操作
行级锁：最大锁开销，可以最大程度地支持并发处理
行锁与表锁的转变
InnoDB 行级锁是通过给索引上的索引项加锁来实现的，InnoDB行级锁只有通过索引条件检索数据，才使用行级锁；否则，InnoDB使用表锁

在不通过索引（主键）条件查询的时候，InnoDB是表锁而不是行锁。也就是说，在没有使用索引的情况下，使用的就是表锁。

### 5.97 间隙锁
间隙锁可以理解为是对于一定范围内的数据进行锁定，如果说这个区间没有这条数据的话也是会锁住的；主要是解决幻读的问题,如果没有添加间隙锁，如果其他事物中添加id在1到100之间的某条记录，此时会发生幻读；另一方面，视为了满足其恢复和赋值的需求（幻读的概念在事务隔离文章中有提到）。

默认情况下，innodb_locks_unsafe_for_binlog是0(禁用)，这意味着启用了间隙锁定：InnoDB使用下一个键锁进行搜索和索引扫描。若要启用该变量，请将其设置为1。这将导致禁用间隙锁定：InnoDB只使用索引记录锁进行搜索和索引扫描。

innodb自动使用间隙锁的条件：
必须在RR级别下
检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）
间隙锁的目的是为了防止幻读，其主要通过两个方面实现这个目的：
防止间隙内有新数据被插入
防止已存在的数据，更新成间隙内的数据（例如防止numer=3的记录通过update变成number=5）
下面将通过例子来详细了解一下间隙锁的出现场景：

```
create table y (
id int primary key ,
num int
);
```
其中id为主键索引，a为二级索引。 数据如下：

```
id	num
1	2
3	4
5	5
7	5
9	8
```
场景：

间隙区间：从查找的字段向上和向下去找。

通过上面的场景，我们可以先找到间隙区间（2，4）（4，5），因此我们可以确定 id 在 1-3，3-5之间，也就是为id为2，4的记录，number在上述间隙区间的值不能够插入。

### 5.8 死锁
为什么会产生死锁
两个事务都持有对方需要的锁，并且在等待对方释放，并且双方都不会释放自己的锁。

`出现死锁的原因`
系统资源不足
进程运行推进的顺序不当
资源分配不当
产生死锁的四个必要条件
互斥条件： 一个资源只能被一个进程使用
请求和保持条件：进行获得一定资源，又对其他资源发起了请求，但是其他资源被其他线程占用，请求阻塞，但是也不会释放自己占用的资源。
不可剥夺条件： 指进程所获得的资源，不可能被其他进程剥夺，只能自己释放
环路等待条件： 进程发生死锁，必然存在着进程-资源之间的环形链
处理死锁的方法
预防，避免，检查，解除死锁

`减少死锁的方法`
使用事务，不使用 lock tables 。
保证没有长事务。
操作完之后立即提交事务，特别是在交互式命令行中。
如果在用 (SELECT … FOR UPDATE or SELECT … LOCK IN SHARE
MODE)，尝试降低隔离级别。
修改多个表或者多个行的时候，将修改的顺序保持一致。
创建索引，可以使创建的锁更少。
最好不要用 (SELECT … FOR UPDATE or SELECT … LOCK IN SHARE MODE)。
如果上述都无法解决问题，那么尝试使用 lock tables t1, t2, t3 锁多张表

可以参考
#### 数据库中的事务和锁

---

## 6.`MySQL事务`-详解

### 6.1 什么是事务
事务是逻辑上的一组操作，要么都执行，要么都不执行。

事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。

### 6.2 事务的特性(ACID)


- `原子性`： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
- `一致性`： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
- `隔离性`： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
- `持久性`： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
并发事务带来的问题
在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

### 6.2.1 脏读,幻读,不可重复读

- 1.`脏读`（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。

- 2.`不可重复读`（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

- 3.`幻读`（Phantom read）: 
幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
不可重复度和幻读区别：

不可重复读的重点是修改，幻读的重点在于新增或者删除。

例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。

例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。

### 6.3 事务隔离级别
SQL 标准定义了四个`隔离级别`：

- 1.READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- 2.READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- 3.REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- 4.SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

| 隔离级别          | 脏读 | 不可重复读 | 幻影读 |
|-----------------|-----|----------|------|
| READ-UNCOMMITTED| √   | √        | √    |
| READ-COMMITTED  | ×   | √        | √    |
| REPEATABLE-READ | ×   | ×        | √    |
| SERIALIZABLE    | ×   | ×        | ×    |


MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation;命令来查看,MySQL 8.0 该命令改为SELECT @@transaction_isolation;
```
mysql> SELECT @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
```

这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 **REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的SERIALIZABLE(可串行化)**隔离级别。

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。

InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。

一个事务对数据库进行操作，这种操作的范围是数据库的全部行，然后第二个事务也在对这个数据库操作，这种操作可以是插入一行记录或删除一行记录，那么第一个是事务就会觉得自己出现了幻觉，怎么还有没有处理的记录呢? 或者 怎么多处理了一行记录呢?

幻读和不可重复读有些相似之处 ，但是不可重复读的重点是修改，幻读的重点在于新增或者删除。

间隙锁的存在，也可以防止一些情况的幻读。

ACID特性的实现原理
ACID特性的实现原理

### 6.4 MVCC
什么是MVCC
MVCC是一种多版本并发控制机制。

MVCC是为了解决什么问题
大多数的MYSQL事务型存储引擎,如,InnoDB，Falcon以及PBXT都不使用一种简单的行锁机制.事实上,他们都和MVCC–多版本并发控制来一起使用.
大家都应该知道,锁机制可以控制并发操作,但是其系统开销较大,而MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销.
MVCC实现
MVCC是通过保存数据在某个时间点的快照来实现的. 不同存储引擎的MVCC. 不同存储引擎的MVCC实现是不同的,典型的有乐观并发控制和悲观并发控制.

MVCC 具体实现分析
下面,我们通过InnoDB的MVCC实现来分析MVCC使怎样进行并发控制的. 
InnoDB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的,这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID)，没开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID.

https://www.codercto.com/a/88775.html

https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc

https://www.cnblogs.com/liulvzhong/articles/9242299.html

### 6.5 事务的使用建议
控制事务大小，减少锁定的资源量和锁定时间长度。
所有的数据检索都通过索引来完成，从而避免因为无法通过索引加锁而升级为表锁。
减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的数据。
在业务条件允许下，尽量使用较低隔离级别的事务隔离。减少隔离级别带来的附加成本。
合理使用索引，让innodb在索引上面加锁的时候更加准确。
在应用中尽可能做到访问的顺序执行（串行）
如果容易死锁，就可以考虑使用表锁来减少死锁的概率

---

## 7.`MySQL索引`- 详解


### 一、什么是索引？
索引是存储引擎用于快速找到记录的一种数据结构。

### 二、理解索引
一个常见的例子就是书的目录。我们都已经养成了看目录的习惯，拿到一本书时，我们首先会先去查看他的目录，并且当我们要查找某个内容时，我们会在目录中查找,然后找到该片段对应的页码，再根据相应的页码去书中查找。如果没有索引(目录)的话,我们就只能一页一页的去查找了。

在MySQL中,假设我们有一张如下记录的表:
```sql
id     name   age
1      huyan  10
2      huiui  18
3      lumingfei  20
4      chuzihang  15
5      nono   21
```

如果我们希望查找到年龄为15的人的名字,在没有索引的情况下我们只能遍历所有的数据去做逐一的对比,那么时间复杂度是O(n)。

而如果我们在插入数据的过程中, 额外维护一个数组,将age字段有序的存储.得到如下数组.
```lua
[10,15,18,20,21]
|  |  |  |  |
|x1,x4,x2,x3,x5]
```

下面的x是模拟数据再磁盘上的存储位置，这个时候如果我们需要查找15岁的人的名字，我们可以对盖数组进行二分查找，众所周知，二分查找的时间复杂度为O(logn)，查找到之后再根据具体的位置去获取真正的数据。

PS:MySQL中的索引不是使用的数组,而是使用的B+树(后面讲),这里用数组举例只是因为比较好理解。

### 三、索引分类

- 普通索引
- 唯一索引
- 主键索引
- 全文索引
- 组合索引

### 四、索引创建
```sql
ALTER TABLE `table_name` ADD INDEX index_name (`column`);
ALTER TABLE `table_name` ADD UNIQUE (`column`);
ALTER TABLE `table_name` ADD PRIMARY KEY (`column`);
ALTER TABLE `table_name` ADD FULLTEXT (`column`);
ALTER TABLE `table_name` ADD INDEX index_name (`column1`, `column2`, `column3`);
```

### 五、索引能为我们带来什么
- 减少查询需要扫描的数据量(加快了查询速度)
- 减少服务器的排序操作和创建临时表的操作(加快了groupby和orderby等操作)
- 将服务器的随机IO变为顺序IO(加快查询速度)

### 六、索引有哪些缺点呢
- 索引占用磁盘或者内存空间
- 减慢了插入更新操作的速度

### 七、聚族索引与非聚族索引的区别
- 按物理存储分类：聚簇索引(clustered index)、非聚簇索引(non-clustered index)
- 聚簇索引的叶子节点就是数据节点，而非聚集群索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针

### 八、前缀索引和索引选择性
- 如果希望给一个很长的字符串上添加索引，那么可以考虑使用前缀索引。

在正式介绍前缀索引之前,我们先大概考虑一下索引的工作步骤，数据库使用索引进行查找的时候,一般是如下几步:

- 在索引的B+树上找到对应的值,比如找到学校名称为卡塞尔学院的一条记录,并且拿到这条数据在磁盘上的地址。
- 根据地址去磁盘上查找,拿到该条数据所有的值。

那么假如在所有的学校名称的值中，卡塞尔就可以唯一的标识这条数据，那么用卡塞尔来做索引是否可以达到和卡塞尔学院做索引相同的效果？

答案是肯定的，而使用卡塞尔的话，是可以减少索引的大小到原来的60%的。这就是前缀索引的作用。

前缀索引: 在对一个比较长的字符串进行索引时,可以仅索引开始的一部分字符,这样可以大大的节约索引空间,从而提高索引效率.但是这样也会降低索引的选择性。

索引的选择性: 不重复的值/所有的值. 可以看出索引的选择性为0-1,最高的就是该列唯一,没有重复值.所以唯一索引的效率是比较好的。

但是在一般情况下,较长的字符串的一些前缀的选择性也是比较好的,这个我们可以算出来.使用下面的语句:
```sql
select 
    count(distinct left(school_name,3))/count(*) as sch3, 
    count(distinct left(school_name,4))/count(*) as sch4,
    count(distinct left(school_name,5))/count(*) as sch5,
    count(distinct school_name)/count(*) as original
from 
    user;
```

其中查找到的original就是原本的选择性,sch3,sch4,sch5分别是取该列的前3,4,5个字符作为索引的时候的选择性.逐步增加这个数值,当选择性与原来相差不大的时候,就是一个比较合适的前缀索引的长度。(一般情况下是这样,但是也有例外,当数据极其不均匀时,这样的前缀索引会在某个特殊的case上表现很差劲)。

找到合适的长度之后,就可以创建一个前缀索引了:```sql alter table user add index sch_pre3(school(3)); ``` 注意:前缀索引和覆盖索引是很难一起使用的,我今天早上刚试过,对索引的优化进行到这一步之后无功而返,具体的原因在下面介绍完覆盖索引之后解释。

### 九、联合索引
一般我们都是有对多个列进行索引的需求的,因为查询的需求多种多样.这个时候我们可以选择建立多个独立的索引或者建立一个联合索引.大多数时候都是联合索引更加合适一些。

假设我们要执行这个语句:```sql select * from user where school_name = '卡塞尔' and age > 20,```我们在school和age上分别建立两个独立的索引,那么我们预期这条查询语句会命中两个索引,但是使用explain命令查看会发现不一定.这是一个玄学的过程.个人没有研究清楚。

从理论上来讲,MySQL在5.0之后的版本里面对支持合并索引,也就是同时使用两个索引,但是MySQL的优化器不一定这样认为,他可能会认为,查询两次B+树的代价高于查询一次索引之后去数据表进行过滤,因此会选择只用一个索引。(我在自己的5张表上做了类似此case的测试,结果都是只使用了一个索引)。

创建联合索引的语法:```sql alter table user add index school_age (school, age); ```

---

## 8.`MySQL体系结构` - 详解

### 8.1 MySQL服务器构成
1.1 客户端与服务器端模型
MySQL是一个典型的C/S模式，单进程多线程的服务结构。MySQL自带的客户端程序在/usr/local/mysql/bin下，如：mysql、 mysqladmin、mysqldump等；服务端程序是mysqld（即守护进程，二进制的程序）


1.2 应用程序连接MySQL的方式
1.2.1 TCP/IP方式
通过网络连接串：
[root@db02 ~]# mysql -uroot -p12345678 -h 127.0.0.1


1.2.2 Socket方式
通过套接字文件：
[root@db02 ~]# mysql -uroot -p12345678 -S /usr/local/mysql/tmp/mysql.sock


提示：服务器默认使用Socket方式连接数据库。

1.3 实例介绍
1.3.1 什么是实例
MySQL在启动过程中会启动后台守护进程，并生成工作线程，预分配内存结构供MySQL处理数据使用，这些MySQL的后台进程+线程+预分配的内存结构就是实例。



### 8.2 MySQL的逻辑结构
2.1 mysqld服务器程序构成
msyqld服务程序分为三层，分别为连接层、SQL层、存储引擎层：



2.1.1 连接层
所包含的服务并不是MySQL所独有的技术。它们都是服务于C/S程序或者是这些程序所需要的 ：连接处理，身份验证，安全性等等：



2.1.2 SQL层
这是MySQL的核心部分，通常叫做 SQL Layer。在 MySQL据库系统处理底层数据之前的所有工作都是在这一层完成的，包括权限判断，sql解析，行计划优化，query cache的处理以及所有内置的函数(如日期、时间、数学运算、加密)等等。各个存储引擎提供的功能都集中在这一层，如存储过程，触发器，视图等：

2.1.3 存储引擎层
通常叫做StorEngine Layer，也就是底层数据存取操作实现部分，由多种存储引擎共同组成。它们负责存储和获取所有存储在MySQL中的数据。就像Linux众多的文件系统一样。每个存储引擎都有自己的优点和缺陷。服务器是通过存储引擎API来与它们交互的。这个接口隐藏了各个存储引擎不同的地方，对于查询层尽可能的透明。这个API包含了很多底层的操作，如开始一个事务，或者取出有特定主键的行。存储引擎不能解析SQL，互相之间也不能通信，仅仅是简单的响应服务器 的请求：



2.2 SQL的整个处理过程


2.2.1 Connectors
指的是不同语言中与SQL的交互。

2.2.2 Management Serveices & Utilities：
系统管理和控制工具。

2.2.3 Connection Pool: 连接池
管理缓冲用户连接，线程处理等需要缓存的需求。负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到线程管理模块。每一个连接上 MySQL Server 的客户端请求都会被分配（或创建）一个连接线程为其单独服务。而连接线程的主要工作就是负责 MySQL Server 与客户端的通信，接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等。

2.2.4 SQL Interface: SQL接口
接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface。

2.2.5 Parser: 解析器
SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。

在 MySQL中我们习惯将所有 Client 端发送给 Server 端的命令都称为 query ，在 MySQL Server 里面，连接线程接收到客户端的一个 Query 后，会直接将该 query 传递给专门负责将各种 Query 进行分类然后转发给各个对应的处理模块。

主要功能：
将SQL语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。
如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的

2.2.6 Optimizer: 查询优化器
SQL语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端请求的 query（sql语句） ，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果，他使用的是“选取-投影-联接”策略进行查询，用一个例子就可以理解：

select uid,name from user where gender = 1;
解析方式：
这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行gender过滤
这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤
将这两个查询条件联接起来生成最终查询结果

2.2.7 Cache和Buffer：查询缓存
他的主要功能是将客户端提交 给MySQL 的Select类query请求的返回结果集cache到内存中，与该query的一个hash值做一个对应。该Query所取数据的基表发生任何数据的变化之后，MySQL会自动使该query的Cache失效。在读写比例非常高的应用系统中，Query Cache对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。

如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的：比如表缓存、记录缓存、key缓存、权限缓存等

2.2.8 存储引擎接口
存储引擎接口模块可以说是MySQL数据库中最有特色的一点了。目前各种数据库产品中，基本上只有MySQL可以实现其底层数据存储引擎的插件式管理。这个模块实际上只是一个抽象类，但正是因为它成功地将各种数据处理高度抽象化，才成就了今天MySQL可插拔存储引擎的特色。

MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。

注意：存储引擎是基于表的，而不是数据库。

2.3 存储引擎概览
存储引擎是充当不同表类型的处理程序的服务器组件。依赖于存储引擎的功能

2.3.1 存储引擎用于
存储数据
检索数据
通过索引查找数据
2.3.2 双层处理
上层包括SQL解析器和优化器
下层包含一组存储引擎
2.3.3 SQL层不依赖于存储引擎
引擎不影响SQL处理
有一些例外
2.3.4 依赖于存储引擎的功能
存储介质
事务功能
锁定
备份和恢复
优化
特殊功能：如全文搜索、引用完整性、空间数据处理等
MySQL“库”的构成


### 8.3 数据库的逻辑结构
3.1.1 库
show databases
use mysql
3.1.2 表
show tables;
3.1.3 记录（行、列）
select user,host,password from user;
desc user
3.2 数据库的物理结构
对象存储中的库相当于目录。表分为MyIASM和InnoDB方式：

MyIASM方式：
```bash
[root@db02 ~]# ll -h /usr/local/mysql/data/mysql/user*
-rw-rw---- 1 mysql mysql  11K Nov 13 11:54 /usr/local/mysql/data/mysql/user.frm     # 存放索引
-rw-rw---- 1 mysql mysql  488 Nov 13 12:33 /usr/local/mysql/data/mysql/user.MYD     # 存放列结构
-rw-rw---- 1 mysql mysql 2.0K Nov 13 12:33 /usr/local/mysql/data/mysql/user.MYI     # 存放行结构
```
InnoDB方式：

共享表空间：ibdata1:ibdata2

独立表空间：t1.frm t1.ibd

创建一个数据库和表，查看一下独立表空间存储的不同

```
mysql> create database leon;
Query OK, 1 row affected (0.00 sec)

mysql> use leon;
Database changed
mysql> create table t1 (id int);
Query OK, 0 rows affected (0.63 sec)

mysql> insert into t1 values(1);
Query OK, 1 row affected (0.01 sec)

mysql> select id from t1;
+------+
| id   |
+------+
|    1 |
+------+
1 row in set (0.00 sec)
```

```
mysql> desc t1;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| id    | int(11) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
1 row in set (0.00 sec)
```

```bash
[root@db02 leon]# ll -h t1*
-rw-rw---- 1 mysql mysql 8.4K Nov 14 10:21 t1.frm       # 存储表结构定义
-rw-rw---- 1 mysql mysql  96K Nov 14 10:21 t1.ibd       # 存储行、列结构
```

3.3 MySQL使用磁盘方式


程序文件随数据目录一起存储在服务器安装目录下。执行各种客户机程序、管理程序和实用程序时将创建程序可执行文件和日志文件。首要使用磁盘空间的是数据目录。

服务器日志文件和状态文件：包含有关服务器处理的语句的信息。日志可用于进行故障排除、监视、复制和恢复。

InnoDB 日志文件：（适用于所有数据库）驻留在数据目录级别。

nnoDB 系统表空间：包含数据字典、撤消日志和缓冲区。
每个数据库在数据目录下均具有单一目录（无论在数据库中创建何种类型的表）。数据库目录存储以下内容：

数据文件：特定于存储引擎的数据文件。这些文件也可能包含元数据或索引信息，具体取决于所使用的存储引擎。

格式文件 (.frm)：包含每个表和/或视图结构的说明，位于相应的数据库目录中。

触发器：某个表关联并在该表发生特定事件时激活的命名数据库对象。
数据目录的位置取决于配置、操作系统、安装包和分发。典型位置是 /var/lib/mysql。MySQL在磁盘上存储系统数据库 (mysql)。mysql 包含诸如用户、特权、插件、帮助列表、事件、时区实现和存储例程之类的信息。

## 9.`sql实战`

给定四个表:

- student（学生表）
- teacher（老师表）
- course（课程表）
- sc（成绩表）
根据题目要求，写出SQL语句。

「问题列表」
- 1、查询每个学生的学号、姓名和每门课的成绩
- 2、查询都学过2号同学（sid=2）学习过的课程的同学的学号
- 3、查询“语文（cid=1）”课程比“数学（cid=2）”课程成绩高的所有学生的学号；
- 4、查询平均成绩大于60分的同学的学号和平均成绩；
- 5、查询所有同学的学号、姓名、选课数、总成绩；
- 6、查询姓“李”的老师的个数；
- 7、查询没学过“叶平”老师课的同学的学号、姓名； 
- 8、查询学过“语文（cid=1）”并且也学过“数学（cid=2）”课程的同学的学号、姓名； 
- 9、查询学过“叶平”老师所教的所有课的同学的学号、姓名；
- 10、查询课程编号“数学（cid=2）”的成绩比课程编号“语文（cid=1）”课程低的所有同学的学号、姓名；
- 11、查询所有课程成绩小于60分的同学的学号、姓名； 
- 12、查询没有学全所有课的同学的学号、姓名； 
- 13、按平均成绩从高到低显示所有学生的“语文“、“数学”、“英语”三门的课程成绩，按如下形式显示： 学生
    ID,语文,数学,英语,有效课程数,有效平均分 
- 14、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分 
- 15、查询男生、女生人数, 以如下形式显示：男生人数，女生人数
- 16、查询课程名称为“数学”，且分数低于60的学生姓名和分数 
- 17、查询两门以上不及格课程的同学的学号及其平均成绩；
- 18、检索“cid=4”课程分数小于60，按分数降序排列的同学学号 


1、查询每个学生的学号、姓名和每门课的成绩；
（1）利用隐式内联，只输出两表中都有的字段

```sql
SELECT 
 student.sid AS 学生ID, 
    student.sname AS 学生姓名, 
    (SELECT course.cname FROM course WHERE course.cid=sc.cid) AS 课程名称, 
    sc.score AS 成绩 
FROM student,sc 
WHERE student.sid = sc.sid
```

（2）利用左连接，假如左表有，右表没有，则按左表为准，右表缺省字段置为NULL

```sql
SELECT 
 student.sid AS 学生ID, 
    student.sname AS 学生姓名, 
    (SELECT course.cname FROM course WHERE course.cid=sc.cid) AS 课程名称, 
    sc.score AS 成绩 
FROM student
LEFT JOIN sc
ON student.sid = sc.sid
```

因为 student 表 和 sc 表没有冗余字段，所以（1）和（2）两种查询方法结果一致。
2、查询都学过2号同学（sid=2）学习过的课程的同学的学号

```sql
SELECT sid 
FROM sc 
WHERE cid IN (SELECT cid FROM sc WHERE sid=2) 
GROUP BY sid 
HAVING COUNT(*) = (SELECT COUNT(*) FROM sc WHERE sid=2)
```

3、查询“语文（cid=1）”课程比“数学（cid=2）”课程成绩高的所有学生的学号；
```sql
SELECT a.sid 
FROM 
(SELECT sid, score FROM sc WHERE cid=1) a, 
(SELECT sid, score FROM sc WHERE cid=2) b 
WHERE a.sid=b.sid AND a.score > b.score;
```

4、查询平均成绩大于60分的同学的学号和平均成绩；

```sql
SELECT sid, AVG(score) 
FROM `sc` 
GROUP BY sid 
HAVING AVG(score) > 60;
```

5、查询所有同学的学号、姓名、选课数、总成绩；

```sql
SELECT a.sid, a.sname, COUNT(a.cid), SUM(a.score) 
FROM
(SELECT student.sid, student.sname, sc.cid, sc.score FROM student JOIN sc WHERE student.sid=sc.sid) a
GROUP BY sid;
```

6、查询姓“周”的老师的个数；

```sql
SELECT COUNT(*) FROM `teacher` WHERE tname LIKE '周%';
```

7、查询没学过“叶平”老师课的同学的学号、姓名；
```sql

# 参考答案
SELECT student.sid,student.sname
FROM student  
WHERE sid NOT IN 
 (
     SELECT DISTINCT(sc.sid) 
     FROM sc, course, teacher 
     WHERE  sc.cid=course.cid AND teacher.tid=course.tid AND teacher.tname='叶平'
    ); 
```

8、查询学过“语文（cid=1）”并且也学过“数学（cid=2）”课程的同学的学号、姓名；

```sql
SELECT student.sid,student.sname 
FROM student, sc 
WHERE student.sid=sc.sid AND sc.cid=1 
AND 
EXISTS
 ( SELECT * FROM sc AS sc_2 WHERE sc_2.sid=sc.sid AND sc_2.cid=2);
```

9、查询学过“叶平”老师所教的所有课的同学的学号、姓名；
```sql
SELECT student.sid,student.sname 
FROM student 
WHERE sid IN 
  (
   SELECT sid 
   FROM sc ,course ,teacher 
   WHERE sc.cid=course.cid AND teacher.tid=course.tid AND teacher.tname='叶平' 
   GROUP BY sid
   HAVING COUNT(sc.cid)=
      (
          SELECT COUNT(cid) 
          FROM course,teacher
          WHERE teacher.tid=course.tid AND teacher.tname='叶平'
      )
  );  
```

10、查询课程编号“数学（cid=2）”的成绩比课程编号“语文（cid=1）”课程低的所有同学的学号、姓名；

```sql
SELECT sid,sname 
FROM student
WHERE sid=
(
 SELECT a.sid 
 FROM 
  (SELECT sid, score FROM sc WHERE cid=1) a, 
  (SELECT sid, score FROM sc WHERE cid=2) b 
 WHERE a.sid=b.sid AND a.score > b.score
)
```

「11」、查询所有课程成绩小于60分的同学的学号、姓名；
```sql

SELECT sid,sname 
FROM student 
WHERE sid NOT IN 
(
    SELECT student.sid FROM student AS s,sc WHERE s.sid=sc.sid AND score>60
); 
```

12、查询没有学全所有课的同学的学号、姓名；

```sql
SELECT student.sid, student.sname
FROM student,sc
WHERE student.sid=sc.sid
GROUP BY sid 
HAVING COUNT(cid) < (SELECT COUNT(cid) FROM course)
```

13、按平均成绩从高到低显示所有学生的“语文“、“数学”、“英语”三门的课程成绩，按如下形式显示： 学生ID,语文,数学,英语,有效课程数,有效平均分

```sql
SELECT sid AS 学生ID,
(SELECT score FROM sc WHERE sc.sid=sc_2.sid AND cid=1) AS 语文,
(SELECT score FROM sc WHERE sc.sid=sc_2.sid AND cid=2) AS 数学,
(SELECT score FROM sc WHERE sc.sid=sc_2.sid AND cid=3) AS 英语,
COUNT(*) AS 有效课程数, 
AVG(score)
FROM sc AS sc_2
GROUP BY sid
ORDER BY AVG(sc_2.score)
```

14、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分

```sql
SELECT cid AS 课程ID, MAX(score) AS 最高分, MIN(score) AS 最低分
FROM sc
GROUP BY cid
```

15、查询男生、女生人数 ：以如下形式显示：男生人数，女生人数

```sql
SELECT 
(SELECT COUNT(ssex) FROM student GROUP BY ssex HAVING ssex='男') AS 男生人数, 
(SELECT COUNT(ssex) FROM student GROUP BY ssex HAVING ssex='女') AS 女生人数; 
```

16、查询课程名称为“数学”，且分数低于60的学生姓名和分数

```sql
SELECT student.sid, student.sname
FROM student,sc
WHERE student.sid=sc.sid AND cid=(SELECT cid FROM course WHERE cname='数学') AND score > 60
```

17、查询两门及两门以上不及格课程的同学的学号及其平均成绩

```sql
SELECT sid, AVG(score) FROM sc WHERE sid IN (SELECT sid FROM sc WHERE score < 60 GROUP BY sid HAVING COUNT(*)>1) GROUP BY sid;
```

18、检索“cid=4”课程分数小于60，按分数降序排列的同学学号
```sql
SELECT sid FROM sc WHERE cid=4 AND score < 60 ORDER BY score DESC
```
--- 

## 10.`两个海量数据的同构表，如何查询数据差异`

一、背景
一道题，应该是很影响职级评定...

二、分析流程
……

相同表结构数据验证：比如修改表逻辑

相似表结构数据验证：比如修改表字段。

新表数据校验：比如新开发了表，选择一个比对表参考等等

三、验数方法
数据验证三步走：

数据量级比对：先比对两个表核心字段数据量级，如果量级不同，两个表数据肯定不一致。
一致性比对：如果量级相同，比对一致性。
差异数据发现：如果数据不一致，把不一致的数据打印出来。
3.1 数据量级比对

```sql
select left_table.pv-right_table.pv as pv_diff,
       left_table.user_id_uv - right_table.user_id_uv as user_id_uv_diff,
       left_table.order_id_uv - right_table.order_id_uv as order_id_uv_diff,
       left_table.city_id_uv - right_table.city_id_uv as city_id_uv_diff
  from (
        select count(1) as pv,
               count(distinct user_id) as user_id_uv,
               count(distinct order_id) as order_id_uv,
               count(distinct city_id) as city_id_uv
          from mart_online.fact_user_order_day
         where dt=20190413
       )left_table
  left outer join (
        select count(1) as pv,
               count(distinct user_id) as user_id_uv,
               count(distinct order_id) as order_id_uv,
               count(distinct city_id) as city_id_uv
          from mart_test.fact_user_order_day
         where dt=20190413
       )right_table
    on 1=1
```

左表pv减去右表pv值为：[0]，核心字段uv差为：[0] 即两个表数据条数相同
```
+-------+----------------+------------------+---------------+
|pv_diff|user_id_uv_diff |order_id_uv_diff  |city_id_uv_diff|
+-------+----------------+------------------+---------------+
|      0|               0|                 0|              0|
+-------+----------------+------------------+---------------+
```

3.2 一致性比对
3.2.1 勾稽验证+md5方法
勾稽是一个小姑娘起的名字，在这里就是看一下左表不为NULL的left_table_num，右表不为NULL的right_table_num，两个表都有的 left_right_equal_num，如果这三个数相等就说明数据是一致的。反之数据肯定不一致，同时可以计算出不一致的条数。

md5：就是计算一行数据的md5值，把它当成key去做比对。尤其是在百亿数据规模的情况下，这种方法也使用。

************ 数据量一致性验证SQL ************* 注意：这里采用full join

```sql
select sum(case when left_table.record_key is not null or left_table.record_key !='' then 1 else 0 end) as left_table_num,
       sum(case when right_table.record_key is not null or right_table.record_key !='' then 1 else 0 end) as right_table_num,
       sum(case when left_table.record_key = right_table.record_key then 1 else 0 end) as left_right_equal_num
  from (
        select md5(
        concat(
              if(user_id is null, '-', cast(user_id as string)),
              if(user_name is null, '-', cast(user_name as string)),
              if(order_id is null, '-', cast(order_id as string)),
              if(city_id is null, '-', cast(city_id as string)),
              if(city_name is null, '-', cast(city_name as string)),
              if(字段n…… is null, '-', cast(字段n…… as string)),
              if(dt is null, '-', cast(dt as string))
              )
        ) as record_key
          from mart_online.fact_user_order_day
         where dt=20190413
       )left_table
  full outer join (
        select md5(
        concat(
              if(user_id is null, '-', cast(user_id as string)),
              if(user_name is null, '-', cast(user_name as string)),
              if(order_id is null, '-', cast(order_id as string)),
              if(city_id is null, '-', cast(city_id as string)),
              if(city_name is null, '-', cast(city_name as string)),
              if(字段n…… is null, '-', cast(字段n…… as string)),
              if(dt is null, '-', cast(dt as string))
              )
        ) as record_key
          from mart_test.fact_user_order_day
         where dt=20190413
       )right_table
    on left_table.record_key=right_table.record_key
```

************ 数据量一致性验证报表 *************
[left_table_num]左表中的数据条数，[right_table_num]右表中的条数，[left_right_equal_num]两个表中相等的数据条数。
左表中有[5660]条数据和右表不一致！
```
+--------------+---------------+--------------------+
|left_table_num|right_table_num|left_right_equal_num|
+--------------+---------------+--------------------+
|      16358699|       16358699|            16353039|
+--------------+---------------+--------------------+
```

3.2.2 暴力比对法
适合具有唯一ID的表，返回空说明验证准确。

```sql
select online.*,
       test.* from(
        select id,
               user_id,
               user_name,
               order_id,
               city_id,
               city_name
          from mart_online.fact_user_order_day
         where dt='20190413'
       )online
  left outer join (
        select id,
               user_id,
               user_name,
               order_id,
               city_id,
               city_name
          from mart_test.fact_user_order_day
         where dt='20190413'
       ) test
    on test.id=online.id
 where test.user_id!=online.user_id
    or test.user_name!=online.user_name
    or test.order_id!=online.order_id
    or test.city_id!= online.city_id
    or test.city_name!= online.city_name
```

3.3 差异数据发现
发现差异数据的方法很多，这里只讲一个通用的方法：逐条比对法（假定两个表有唯一的ID，如果没有唯一ID，其实md5不一样的数据就不一致），这种方法适合小规模数据，当然我们真是实现的时候是结合一致性验证的情况，直接就能找到差异的数据并打印出来。

```
select left_table.*,
       right_table.*
  from (
        select *
          from mart_online.fact_user_order_day
         where dt=20190413
       )left_table
  full outer join (
        select *
          from mart_test.fact_user_order_day
         where dt=20190413
       )right_table
    on left_table.id = right_table.id
   and left_table.dt = right_table.dt
 where COALESCE(left_table.user_id, 0) <> COALESCE(right_table.user_id, 0)
    or COALESCE(left_table.user_name, 0) <> COALESCE(right_table.user_name, 0)
    or COALESCE(left_table.order_id, 0) <> COALESCE(right_table.order_id, 0)
    or COALESCE(left_table.city_id, 0) <> COALESCE(right_table.city_id, 0)
    or COALESCE(left_table.city_name, 0) <> COALESCE(right_table.city_name, 0)
    or COALESCE(left_table.字段n……, 0) <> COALESCE(right_table.字段n……, 0)
```

不一致的条数：[5660]，case如下表所示：
```
+-------+----------------+------------------+---------------+---------------+
|id     |left_user_id    |left_字段n……       |right_user_id  |right_字段n……   |
+-------+----------------+------------------+---------------+---------------+
|      0|               1|             哇哈哈|              1|           养乐多|
+-------+----------------+------------------+---------------+---------------+
```

四、总结
如上验数SQL，可以通过代码封装，自动生成，就可以做成自动化数据验证的小工具了。真实情况比较复杂，要考虑字段的识别，where条件，两个表是否有唯一ID，没有唯一ID如何处理等等。