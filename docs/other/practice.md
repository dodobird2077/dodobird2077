# 练习题

## 方向

##### 语言层面：

了解 PHP 8 语法特征，与 PHP 7 有什么不同，带来了那些改变。
了解现代框架，了解其高性能的原因，未来大部分 PHP 项目很可能都会基于此构建，比如 Workerman。Workerman 是什么
掌握的框架和熟练使用的某一框架。

##### 数据层面

MYSQL 的优化、索引、事务、数据类型，每一项都可以深入复习下。
盘点那些被问烂了的 Mysql 面试题

Redis 的基本知识、语法、数据类型，各种数据类型的运用环境。
在面试前必须要知道的 Redis 面试内容

关键事故术语背后是什么比如：缓存雪崩、穿透、死锁
Redis 击穿、穿透、雪崩产生原因以及解决思路

##### 网络层面

*   TCP/IP 、HTTP1/HTTP2、套接字
*   TCP/IP 协议
*   软件工程、架构
*   编程思想
*   代码风格 PHP 代码简洁之道
*   主流架构
*   算法

#### `php知识点`

*   <https://www.kancloud.cn/martist/be_new_friends>
*   <https://www.kancloud.cn/martist/phper-will-get-bat-tmd-offer-in-2021>

#### `其他`

看看 redis、mysql 方面的书，比如 redis 的《redis 运维与开发》、《redis 设计与实现》，mysql 方面可以看看掘金小册 小孩子的《从根上理解 mysql》。
计算机网络的话主要，可以看看 tcp 三次握手、四次挥手这些老掉牙的东西，还有 web 安全方面，比如 SQL 注入、XSS、CSRF 防范，还有设计模式，
另外 php 框架的源码也得看看一两个，主要生命周期，依赖注入、服务定位器什么之类。

## 1.手写算法

### 1.1 php实现冒泡排序

```php

// 冒泡排序 (错误写法)
function BubbleSort($arr) 
{ 
    for($i = 0; $i < count($arr); $i++) { 
        for($j = 0; $j < count($arr); $j++) { 
            echo "[i:{$i}]={$arr[$i]},  [j:{$j}]={$arr[$j]} " . PHP_EOL;
            if ($arr[$i] > $arr[$j]) { 
                $num = $arr[$i];
                $arr[$i] = $arr[$j];
                $arr[$j] = $num;
            } 
        } 
    } 
    return $arr; 
}

// 冒泡排序, 正确写法
function BubbleSortTrue($arr) 
{ 
    // (外层)循环控制冒泡的(轮数)
    for ($i = 0; $i < count($arr); $i++) { 

        // (内层)循环用于比较相邻元素并进行(交换)
        // 注意：每轮冒泡将当前未排序部分的最大元素移动到正确的位置
        // 因此，内层循环不需要再考虑已经排序好的元素，从而提高效率

        for ($j = 0; $j < count($arr) - $i - 1; $j++) { 
            // 如果前一个元素大于后一个元素，则交换它们的位置
            if ($arr[$j] > $arr[$j + 1]) {
                // 交换元素
                $temp = $arr[$j];
                $arr[$j] = $arr[$j + 1];
                $arr[$j + 1] = $temp;
            }
        } 
    } 
    // 返回排序好的数组
    return $arr; 
} 

$array = [4, 2, 7, 1, 9, 5];
$res = BubbleSortTrue($array); 
print_r($res);
// 结果 [1,2,4,5,7,9]
```

![logo转存失败，建议直接上传图片文件](<转存失败，建议直接上传图片文件 ../_media/img/suanfa/bubble.gif>)

*   图中可以看出：
    *   第一轮排序将数字 6 移动到最右边；
    *   第二轮排序将数字 5 移动到最右边，同时中途将 1 和 2 排了序；
    *   第三轮排序时，没有发生交换，表明排序已经完成，不再继续比较

*   `$i, 就是用来控制多少轮的, $j则是用来进行交换的`

### 1.2 二分查找算法

```php
function binarySearch($arr, $target) {
    $len = count($arr);
    $left = 0;
    $right = $len - 1;
    while ($left <= $right) {
        $mid = floor(($left + $right) / 2);
        if ($arr[$mid] == $target)
    }
}
```

## 2.常见练习题

### 2.1 php新特性

1.  **标量类型声明 (PHP 7.0):** 增加了对标量类型的声明，提高了代码的可读性和可维护性。

2.  **返回类型声明 (PHP 7.0):** 函数和方法现在可以指定返回类型，有助于更好地定义和理解代码的期望行为。

3.  **可空类型 (PHP 7.1):** 允许在类型声明中使用 `null`，提高了对可空变量的处理。

4.  **类型属性声明 (PHP 7.4):** 类可以有类型声明的属性，提高了面向对象编程的类型安全性。

5.  **箭头函数 (PHP 7.4):** 引入了类似 JavaScript 的箭头函数，简化了匿名函数的写法。

6.  **预加载 (PHP 7.4):** 允许在 Web 服务器启动时提前加载一些常用的类和文件，提高了性能。

7.  **异常处理改进 (PHP 7.0 - 7.1):** 异常层次结构的改进和许多致命错误转换为异常，提高了异常处理的灵活性。

8.  **合并赋值运算符 (`??=`) (PHP 7.4):** 允许在变量为 `null` 时进行赋值，简化了对可能为 `null` 的变量的处理。

9.  **数组中的展开运算符 (`...`) (PHP 7.4):** 允许使用 `...` 运算符在数组中展开元素，提高了数组操作的灵活性。

10. **空合并运算符 (`??`) (PHP 7.0):** 提供了一种简洁的方法来处理变量可能为 `null` 的情况，减少了冗余的三元运算符。

*   PHP7增`类型`，`空型``返回`与`标量`。
*   `箭头函数``预加载`，`合并``运算`与`异常`。

#### 2.1.2 php8新特性

PHP 8 引入了多项重要的变化：

1.  **即时编译（JIT）：** 引入 JIT 编译器，显著提升 PHP 脚本性能。

2.  **属性：** 支持属性（Attributes），可在类、方法等结构上添加元数据。

3.  **联合类型：** 允许变量具有多个类型之一，提高了类型灵活性。

4.  **命名参数：** 引入了命名参数，通过参数名传递参数，提高了函数调用的可读性。

5.  **匹配表达式：** 引入了 `match` 表达式，替代了一些复杂的 `switch` 语句。

6.  **安全空值操作符：** 引入了 `?->` 运算符，简化了对可能为 `null` 的变量的访问。

7.  **构造器属性提升：** 允许在类的构造函数中直接声明和初始化属性。

8.  **弱映射：** 引入了弱映射，使得对象作为键时更容易被垃圾回收。

*   `即时编译`与属性,表达式`联合类型`;
*   `命名参数`空操作,弱映射`构造属性`

### 2.2 自己显示substr方法, 主要是通过: `$str[$i]`来进行字符串的截取

## 3.Redis

缓存雪崩、穿透、死锁 Redis 击穿、穿透、雪崩产生原因以及解决思路

缓存雪崩、穿透、死锁，以及 Redis 击穿、穿透、雪崩是与缓存相关的一些常见问题。以下是它们的产生原因和解决思路：

### 1.缓存雪崩（重点1）：

**产生原因：** 大量缓存在同一时间失效，导致大量请求直接击穿数据库。
**解决思路：**

*   设置不同的过期时间，避免同时失效。
*   引入缓存预热，提前加载热门数据。
*   使用分布式锁，防止大量请求同时更新缓存。

### 2.缓存穿透（重点2）：

**产生原因：** 恶意请求或者查询不存在的数据，导致请求直接落到数据库。
**解决思路：**

*   使用布隆过滤器等机制拦截不存在的请求。
*   缓存空值（Null Object Pattern）。
*   对于频繁不存在的 key，设置短暂的缓存时间。

### 3.缓存死锁：

**产生原因：** 在分布式系统中，多个请求同时获取锁，但由于各种原因未能正确释放。
**解决思路：**

*   使用分布式锁，确保锁的互斥性。
*   设置锁的过期时间，防止死锁的持续发生。

### 4.Redis 击穿：

**产生原因：** 针对一个热点数据的大量请求，在缓存失效时直接访问数据库。
**解决思路：**

*   设置热点数据永不过期或过期时间较长。
*   使用互斥锁，保证只有一个请求去数据库查询。

### 5.Redis 穿透：

**产生原因：** 请求的 key 在缓存中不存在，且数据库中也不存在，导致频繁访问数据库。
**解决思路：**

*   使用布隆过滤器过滤无效请求。
*   缓存空值，避免频繁查询数据库。

### 6.Redis 雪崩：

**产生原因：** 缓存中的大量数据在同一时间失效，导致请求直接访问数据库。
**解决思路：**

*   设置不同的过期时间，避免同时失效。
*   使用缓存预热，提前加载热门数据。
*   引入分布式锁，防止大量请求同时更新缓存。

综合来说，缓存问题的解决思路包括:

*   A.设置合理的过期时间、
*   B.使用分布式锁、
*   C.引入缓存预热、
*   D.使用布隆过滤器等机制

`以确保系统在缓存失效或请求高峰时能够保持稳定`

*   布隆过滤器(有点像in\_array):
    *   布隆过滤器是一种高效的数据结构，用于快速判断一个元素是否可能存在于一个集合中，具有较小的存储空间和快速查询的优点
    *   适用于缓存、防止缓存穿透等场景。可以使用第三方库如 `phpbloomd` 来方便地实现布隆过滤器。

### 应用场景

*   场景 1：**缓存雪崩**

*   1.1 `情景描述`：
    假设你有一个热门商品列表，每个`商品`都被缓存在 Redis 中，并且这些商品的缓存都在同一时间失效。

*   1.2 `问题可能性`：
    当这些缓存同时失效时，系统会接收到大量请求，这些请求会直接访问数据库获取商品数据，导致数据库压力剧增，可能导致数据库性能问题。

*   1.3 `解决思路`：

> 不同的过期时间： 给每个商品的缓存设置不同的过期时间，避免它们在同一时间失效。

> 缓存预热： 提前加载热门商品数据到缓存中，避免缓存失效时大量请求直接访问数据库。

场景 2：**缓存穿透**

*   2.1 情景描述：
    假设你有一个根据用户 ID 缓存用户信息的系统，而有恶意用户发送不存在的用户 ID 请求。

*   2.2 问题可能性：
    这些恶意请求会直接穿透缓存，导致系统每次请求都去数据库查询不存在的用户信息，造成数据库负担。

*   2.3 解决思路：

> 布隆过滤器： 使用布隆过滤器拦截不存在的用户 ID 请求，避免直接访问数据库。

> 缓存空值： 缓存不存在的用户 ID，避免频繁查询数据库。

## 4.MySQL优化

> 重点是索引, 事务, 隔离级别, 死锁等

### 4.1 常见问题

- 搬到了对应的地方

### 4.2 常识和规范

根据你发送的五部分内容，以下是对其进行总结和归纳的重点：

1. 数据库性能优化：
   - 使用索引来提高查询性能。
   - 避免全表扫描和不必要的数据检索。
   - 合理设置数据库连接池和缓存大小。
   - 使用合适的数据类型和字段长度。
   - 避免频繁的数据库连接和断开操作。

2. 数据库高可用性：
   - 使用主从复制来实现数据的冗余备份和读写分离。
   - 避免单点故障，使用负载均衡和故障转移机制。
   - 定期备份数据，并测试恢复过程的可靠性。
   - 监控数据库的运行状态和性能指标。

3. 数据库安全性：
   - 使用强密码和加密通信来保护数据库账号和数据的安全。
   - 限制数据库账号的权限，遵循最小权限原则。
   - 定期更新数据库软件和补丁，防止安全漏洞的利用。
   - 使用防火墙和访问控制列表来限制对数据库的访问。

4. SQL查询优化：
   - 编写高效的SQL查询语句，避免使用复杂的子查询和嵌套查询。
   - 使用JOIN操作来优化多表查询。
   - 避免在循环中执行SQL查询，尽量减少数据库的访问次数。
   - 使用EXPLAIN工具来分析查询执行计划，优化索引和表结构。

5. 数据库操作行为规范：
   - 对于大批量写操作，分批多次进行操作，避免严重的主从延迟。
   - 避免产生大事务操作，减少阻塞和对数据库性能的影响。
   - 对大表的结构修改，使用合适的工具进行处理，避免主从延迟和表锁。
   - 禁止为程序使用的账号赋予超级权限，遵循权限最小原则。

---
### 4.3 Explain详解

#### 比如我执行: 

`EXPLAIN select name,gender,age from user where name='张三' and gender=1`

#### 结果
| id  | select_type | table | type  | possible_keys           | key       | key_len | ref   | rows | Extra |
| --- | ----------- | ----- | ----- | ----------------------- | --------- | ------- | ----- | ---- | ----- |
| 1   | SIMPLE      | user  | const | uni_user,index_sex,indx_name_sex | uni_user  | 41      | const | 1    |       |

#### 介绍

| 序号 | 名称           | 名称解释                                                                                                                     |
| ---- | -------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| 1    | id             | SQL执行的顺序的标识，SQL从大到小的执行，即降序执行                                                                             |
| 2    | select_type    | SIMPLE：简单SELECT（不使用UNION或子查询等）<br> PRIMARY：最外层的select UNION，UNION中的第二个或后面的SELECT语句<br> ... |
| 3    | table          | 显示这一行的数据是关于哪张表的。<br> 有时不是真实的表名字，看到的是derived x（x是个数字，是第几步执行的结果）                 |
| 4    | `type`           | 连接使用了哪种类别，有无使用索引。<br> 从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL                          |
| 5    | possible_keys  | MySQL能使用哪个索引在该表中找到行。如果是NULL，则没有相关的索引。                                                              |
| 6    | key            | MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。                                                                  |
| 7    | key_len        | MySQL决定使用的键长度。如果键是NULL，则长度为NULL。                                                                           |
| 8    | ref            | 使用哪个列或常数与key一起从表中选择行。                                                                                        |
| 9    | `rows`           | MySQL认为执行查询时必须检查的行数。                                                                                           |
| 10   | Extra          | MySQL解决查询的详细信息：<br> (1). Distinct<br> (2). Not exists<br> (3). Range checked for each Record<br> ...                |

#### 详细解释

4. **`type`** `性能由高到低排列`
    - ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行
    - index: Full Index Scan，index与ALL区别为index类型只遍历索引树
    - range: 只检索给定范围的行，使用一个索引来选择行
    - ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
    - eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件
    - const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。
      如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system
    - NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。


---
### 4.4 查询优化

#### 4.4.1 `SQL通用优化方案`:
1. 使用参数化查询：防止SQL注入，预编译SQL命令提高效率
2. 去掉不必要的查询和搜索字段：其实在项目的实际应用中，很多查询条件是可有可无的，能从源头上避免的多余功能尽量砍掉，这是最简单粗暴的解决方案。
3. 选择最有效率的表名顺序: 数据库的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表放在最后，如果有3个以上的表连接查询,那就需要选择那个被其他表所引用的表放在最后。
4. 不要使用select *：不要使用select *，以提高查询效率，减少输出的数据量，提高传输速度（数据库或在解析过程中将"*"依次转换成所有列名，这意味着消耗更多的时间）
5. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
6. 减少访问数据库的次数：通过存储过程等，把多条语句放在一个存储过程中执行，减少数据库访问次数
7. 整合简单的、无关联的数据库访问：如果你有几个简单的数据库查询语句,你可以把它们整合到一个查询中(即使它们之间没有关系)）
8. 删除重复记录：删除重复记录，减少数据库文件大小
9. 使用表的别名(Alias)：当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误.
10. 使用列的别名：当列的名称很长的时候，使用简短的列的别名可以查询结果更清晰，更简洁。
11. 用EXISTS替代IN、用NOT EXISTS替代NOT IN：无论在哪种情况下,NOT IN都是最低效的 (因为它对子查询中的表执行了一个全表遍历). 为了避免使用NOT IN ,我们可以把它改写成外连接(Outer Joins)或NOT EXISTS.
12. 统计相关的查询，影响结果集往往巨大，应避免在业务高峰期执行统计相关的查询，或者仅在从库中执行统计查询。同时建议把数据先保存在内存、缓存中(如redis)，再按一定策略写入数据库。
13. select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的，可以用其他方法代替。
14. 使用truncate代替delete清空整个数据表：当删除表中的记录时,在通常情况下, 回滚段(rollback segments ) 用来存放可以被恢复的信息. (可以恢复到执行删除命令之前的状态) 而当运用TRUNCATE时, 回滚段不再存放任何可被恢复的信息.当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短.

#### 4.4.2 字段类型优化：
1. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。
2. 最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.（备注、描述、评论之类的可以设置为 NULL）

#### 4.4.3 where条件语句优化：
1. WHERE子句中的连接顺序：数据库采用自右而左的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前(左), 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾(右).
2. 避免在where语句中出现字段的类型转换（字段的类型和传入的参数类型不一致的时候发生的隐式类型转换）
3. 不要在where条件语句中的"="左边进行函数、算数运算或其他表达式运算，可以通过使用冗余字段来替代函数运算，否则系统无法正确使用索引
4. where 子句中对字段进行 null 值判断、包含not、!=、<>等操作符，或like的关键词前加%(like '%关键词')，都无法使用索引，从而引发全表扫描.
5. 使用like进行模糊查询时应注意,除非必要，否则不要在关键词前加%，否则必然导致全表查询

### 4.4.4 索引优化：
1. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。
2. 用索引提高效率：合理使用索引和复合索引同样能提高效率.但使用索引是有代价的, 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时, 索引本身也会被修改. 这意味着每条记录的INSERT , DELETE , UPDATE将为此多付出4 , 5 次的磁盘I/O . 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.。定期的重构索引是有必要的。
3. 在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用。
4. 要注意索引的维护，周期性重建索引，重新编译存储过程。

#### 4.4.5 分页语句优化：
1. 分页查询的优化。页数比较多的情况下，如limit 10000,10 影响的结果集是10010行，查询速度会比较慢。推荐的解决方案是：先只查询主键select id from table where .. order by .. limit 10000,10(搜索条件和排序请建立索引)，再通过主键去获取数据。
2. 对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。

#### 4.4.6 事务的优化:
1. 尽量使用COMMIT：尽可能在程序中使用commit，这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少，commit每个数据库引擎都不同，sqlserver默认一条sql语句就是一个事务。
2. 尽量避免大事务操作，提高系统并发能力。
3. 只在必要的情况下才使用begin tran：begin tran保证了数据的一致性，可以确保要么几个表都修改成功，要么都不成功，但Begin tran付出的代价是在提交之前，所有SQL语句锁住的资源都不能释放，直到commit掉。Begin tran使用的原则是，在保证数据一致性的前提下，begin tran 套住的SQL语句越少越好！有些情况下可以采用触发器同步数据，不一定要用begin tran。

#### 4.4.7 临时表优化：
1. 避免频繁创建和删除临时表，以减少系统表资源的消耗。
2. 使用“临时表”暂存中间结果：将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。同时也能简化sql语句的复杂度。
3. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。
4. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。
5. 如果临时表的数据量较大，需要建立索引，那么应该将创建临时表和建立索引的过程放在单独一个子存储过程中，这样才能保证系统能够很好的使用到该临时表的索引。
6. 尽量避免使用distinct、order by、group by、having、join、cumpute，因为这些语句会加重tempdb的负担。
7. 慎用大的临时表与其他大表的连接查询和修改，减低系统表负担，因为这种操作会在一条语句中多次使用tempdb的系统表。

#### 4.4.8 游标优化：
1. 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。
2. 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。
3. 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。


---
### 4.5 锁

#### 用途
多个查询需要在同一时刻修改数据，会产生并发控制的问题。使用锁可以有效解决这个问题

#### 4.5.1 锁的分类
- 按照锁的粒度划分：`行锁`、`表锁`、`页锁`
- 按照锁的使用方式划分：`共享锁`、`排它锁`（悲观锁的一种实现）
- 还有两种思想上的锁：`悲观锁`、`乐观锁`
- InnoDB中有几种行级锁类型：Record Lock(在索引记录上加锁)、Gap Lock（间隙锁）、Next-key Lock(临键锁)

#### 4.5.2 行锁
​行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。
**行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。有可能会出现死锁的情况。**

行级锁按照使用方式分为`共享锁`和`排他锁`。

##### 4.5.2.1 共享锁(同一时刻可以同时读取同一个资源)：
##### 4.5.2.2 排他锁 (一个写锁会阻塞其他的写锁和读锁)：


`共享锁`用法（S锁 读锁）
​ 若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

select ... lock in share mode;
共享锁就是允许多个线程同时获取一个锁，一个锁可以同时被多个线程拥有。

`排它锁`用法（X 锁 写锁）
​ 若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

select ... for update
​ 排它锁，也称作独占锁，一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁。

#### 4.5.3 表锁
​ 表级锁是mysql锁中粒度`最大`的一种锁，表示当前的操作对整张表加锁，资源开销比行锁少，不会出现死锁的情况，但是发生锁冲突的概率很大。被大部分的mysql引擎支持，MyISAM和InnoDB都支持表级锁，但是InnoDB默认的是行级锁。

共享锁用法：

LOCK TABLE table_name [ AS alias_name ] READ
排它锁用法：

LOCK TABLE table_name [AS alias_name][ LOW_PRIORITY ] WRITE
解锁用法：

unlock tables;

#### 4.5.4 页锁
​ 页级锁是MySQL中锁定粒度`介于行级锁和表级锁中间`的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁
。

#### 4.5.5 悲观锁和乐观锁
无论是悲观锁还是乐观锁，都是人们`定义出来的概念`，可以认为是一种思想。其实不仅仅是数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。

---
### 4.6 事务

#### 4.6.1 什么是事务
事务是逻辑上的一组操作，要么都执行，要么都不执行。

#### 4.6.2 事务的特性(ACID)


- `原子性 - Atomicity`： 事务是最小的执行单位，要么全部成功, 要么全部失败. 不可能只执行一部分操作.
- `一致性 - Consistency`： 执行事务前后，总是`从一个一致性的状态`转移到`另一个一致性的状态`, `不会存在中间状态`；
- `隔离性 - Isolation`： 并发访问数据库时，一个用户的事务不被其他事务所干扰，`各并发事务之间数据库是独立的`；
- `持久性 - Durability`： 一旦事务提交,那么就永远是这样了,哪怕系统崩溃也不会影响到这个事务的结果

**并发事务带来的问题**

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

#### 4.6.2.1 脏读,幻读,不可重复读 (并发事务造成)

- 1.`脏读`（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。

- 2.`不可重复读`（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

- 3.`幻读`（Phantom read）: 
幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

##### 不可重复度和幻读区别：

不可重复读的重点是修改，幻读的重点在于新增或者删除。

例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。

例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。

#### 4.6.3 事务隔离级别 (1.读未提交, 2.读已提交, 3.可重复读, 4.可串行化)
SQL 标准定义了四个`隔离级别`：

- 1.READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- 2.READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- 3.REPEATABLE-READ(`可重复读`)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以`阻止脏读和不可重复读`，但`幻读`仍有可能发生。
- 4.SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

| 隔离级别          | 脏读 | 不可重复读 | 幻影读 |
|-----------------|-----|----------|------|
| READ-UNCOMMITTED| √   | √        | √    |
| READ-COMMITTED  | ×   | √        | √    |
| REPEATABLE-READ | ×   | ×        | √    |
| SERIALIZABLE    | ×   | ×        | ×    |


MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation;命令来查看,MySQL 8.0 该命令改为SELECT @@transaction_isolation;
```
mysql> SELECT @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
```

这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在  **REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的SERIALIZABLE(可串行化)** 隔离级别。

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):
但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。



#### 4.6.4 MVCC

- 1.MVCC是一种多版本并发控制机制。
- 2.MVCC是为了解决: 锁机制可以控制并发操作,但是其系统开销较大,而MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销
- 3.MVCC是通过快照来实现


#### 4.6.5 事务的使用建议
- 控制事务大小，减少锁定的资源量和锁定时间长度。
- 所有的数据检索都通过索引来完成，从而避免因为无法通过索引加锁而升级为表锁。
- 减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的数据。
- 在业务条件允许下，尽量使用较低隔离级别的事务隔离。减少隔离级别带来的附加成本。
- 合理使用索引，让innodb在索引上面加锁的时候更加准确。
- 在应用中尽可能做到访问的顺序执行（串行）
- 如果容易死锁，就可以考虑使用表锁来减少死锁的概率


---

### 4.7 索引

#### 1. **什么是索引?**

索引是一种数据结构,可以帮助我们快速的进行数据的查找.

---
#### 2. **索引是个什么样的数据结构呢?**

在MySQL中使用较多的索引有`Hash索引`,`B+树索引`等,而我们经常使用的InnoDB存储引擎的`默认`索引实现为:`B+树`索引.

**B+树索引** `范围查询、排序和数据动态变化的场景`

- 支持范围查询：
- 适应性强：
- 适用于范围查询和排序
- 磁盘IO较少
- 冗余数据

**Hash索引**  `快速的精确匹配查询的场景`
- 快速查找
- 精确匹配：
- 不支持范围查询：
- 不适用于排序。


---
#### 3. **什么是聚簇索引, 和B+树有什么关系?**

`聚簇索引和非聚簇索引`：

-  `聚簇索引`：一种索引结构，其中索引中的叶子节点存储了`完整的数据行`(也就是索引中已经存储了数据,不用回表)
-  `非聚簇索引`：一种索引结构，其中索引中的叶子节点存储了指向数据行的指针或引用。非聚簇索引可以通过 `回表查询`获取完整的数据行。

一般情况下，除了主键索引，我们自己设置的索引通常都是非聚簇索引, （唯一索引、普通索引、组合索引）都是`非聚簇索引`

---
#### 4. **在建立索引的时候,都有哪些需要考虑的因素呢?**

- 字段的使用频率, 经常作为条件进行查询的字段比较适合.
- 如果需要建立联合索引的话,还需要考虑联合索引中的顺序.
- 防止过多索引(一般不超过5个)


---
#### 5. **联合索引, 最左原则是什么?**

MySQL的联合索引是指在多个列上创建的组合索引。在使用联合索引时，MySQL遵循一个重要的原则，即`最左前缀原则`。

最左前缀原则指的是，在联合索引中，查询时必须`从联合索引的最左边的列开始`，并且按照索引列的顺序逐个列出。
这样才能充分利用索引的效果。如果查询不满足最左前缀原则，那么索引可能无法发挥作用，导致查询性能下降。


假设有一个表 `user`，包含以下列：`id`、`name`、`age`、`gender`, 创建了联合索引 `idx_name_age`


1. 查询1(`符合`)：
   ```sql
   SELECT * FROM user WHERE name = 'John' AND age = 25;
   符合，从联合索引的最左边的列 `name` 开始，并且按照索引的顺序逐个列出
   ```

2. 查询2(`符合`)：
   ```
   SELECT * FROM user WHERE name = 'John';
   符合，从联合索引的最左边的列，因为从联合索引的最左边的列 `name` 开始，按照索引的顺序逐个列出。虽然查询中没有使用到 `age` 列，但是索引仍然可以被利用，加速查询。
   ```

3. 查询3(`不符合`)：
   ```
   SELECT * FROM user WHERE age = 25;
   ```
   这个查询不满足最左前缀原则，因为它**没有从联合索引的最左边的列 `name` 开始**, 而是从`age`开始。虽然索引 `idx_name_age` 存在，但是在这个查询中无法利用该索引，MySQL可能会选择其他的查询执行计划。
